{"version":3,"file":"CharacterController.js","mappings":"CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,mBAC7B,GAAqB,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,aAAcJ,OAClB,CACJ,IAAIM,EAAuB,iBAAZL,QAAuBD,EAAQG,QAAQ,cAAgBH,EAAQD,EAAc,SAC5F,IAAI,IAAIQ,KAAKD,GAAuB,iBAAZL,QAAuBA,QAAUF,GAAMQ,GAAKD,EAAEC,EACvE,CACA,CATD,CASGC,MAAOC,G,kCCTVP,EAAOD,QAAUQ,C,GCCbC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaZ,QAGrB,IAAIC,EAASQ,EAAyBE,GAAY,CAGjDX,QAAS,CAAC,GAOX,OAHAc,EAAoBH,GAAUV,EAAQA,EAAOD,QAASU,GAG/CT,EAAOD,OACf,CCrBAU,EAAoBK,EAAKd,IACxB,IAAIe,EAASf,GAAUA,EAAOgB,EAC7B,IAAOhB,EAAiB,QACxB,IAAM,EAEP,OADAS,EAAoBQ,EAAEF,EAAQ,CAAEX,EAAGW,IAC5BA,CAAM,ECLdN,EAAoBQ,EAAI,CAAClB,EAASmB,KACjC,IAAI,IAAIC,KAAOD,EACXT,EAAoBW,EAAEF,EAAYC,KAASV,EAAoBW,EAAErB,EAASoB,IAC5EE,OAAOC,eAAevB,EAASoB,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDV,EAAoBW,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFjB,EAAoBqB,EAAK/B,IACH,oBAAXgC,QAA0BA,OAAOC,aAC1CX,OAAOC,eAAevB,EAASgC,OAAOC,YAAa,CAAEC,MAAO,WAE7DZ,OAAOC,eAAevB,EAAS,IAAc,CAAEkC,OAAO,GAAO,E,4ICwB9D,aAu8DI,WAAYC,EAAcC,EAAyBC,EAAcC,EAAgBC,QAAA,IAAAA,IAAAA,GAAA,GAAjF,WAr8DQ,KAAAC,EAAgB,KAChB,KAAAC,EAAsB,KAQtB,KAAAC,EAAmB,IAEnB,KAAAC,EAAyB,GACzB,KAAAC,EAAyB,GAEzB,KAAAC,EAAeC,KAAKC,GAAKC,KAAKL,EAAiB,IAC/C,KAAAM,EAAeH,KAAKC,GAAKC,KAAKJ,EAAiB,IAG/C,KAAAM,EAAsB,IAGtB,KAAAC,EAAwB,IAAIC,EAE5B,KAAAC,GAA0B,EAC1B,KAAAC,EAAyB,EAAAC,QAAA,OAEzB,KAAAC,GAA0B,EAE1B,KAAAC,EAAiB,EAAAF,QAAA,aAsejB,KAAAG,EAAQ,EACR,KAAAC,EAAY,EAsEZ,KAAAC,GAAa,EACb,KAAAC,GAAgB,EAgGhB,KAAAC,GAAoB,EA4BpB,KAAAC,GAAqB,EAkCrB,KAAAC,EAA2B,KAC3B,KAAAC,EAAuB,EAAAV,QAAA,OACvB,KAAAW,EAAqB,EACrB,KAAAC,GAAqB,EAErB,KAAAC,EAAwB,EAExB,KAAAC,GAAuB,EACvB,KAAAC,GAAuB,EACvB,KAAAC,GAAuB,EACvB,KAAAC,EAAuB,EAAAjB,QAAA,OAoEvB,KAAAkB,EAAiB,IACjB,KAAAC,EAAS,KAGT,KAAAC,EAAyB,EAEzB,KAAAC,EAAoB,EAkGpB,KAAAC,EAAuB,EACvB,KAAAC,EAAQ,EACR,KAAAC,GAAa,EACb,KAAAC,GAAS,EACT,KAAAC,IAAS,EACT,KAAAC,IAAoB,EAoU5B,KAAAC,GAAsB,KACtB,KAAAC,GAAmB,CAAC,EAkHZ,KAAAC,GAAwB,EAgExB,KAAAC,GAAoB,EACpB,KAAAC,GAAkB,GAiBlB,KAAAC,IAAiC,EACjC,KAAAC,IAAQ,EA2CR,KAAAC,GAAgC,IAAIC,IAWpC,KAAAC,GAAY,IAAI,EAAAC,IAAI,EAAAtC,QAAA,OAAgB,EAAAA,QAAA,MAAe,GACnD,KAAAuC,GAAmB,EAAAvC,QAAA,OAGnB,KAAAwC,GAAsB,GAEtB,KAAAC,GAAgC,IAAIC,MACpC,KAAAC,IAAiB,EACjB,KAAAC,GAAgB,GAwHhB,KAAAC,IAAiB,EA4FjB,KAAAC,IAAgB,EAsGhB,KAAAC,IAAiB,EAuEjB,KAAAC,GAA2B,KAgE3B,KAAAC,IAAqB,EACrB,KAAAC,IAAmB,EA0BvBzD,KAAK0D,GAAUtE,EAIK,MAAhBY,KAAK0D,KACL1D,KAAKyD,IAAU,EACfzD,KAAK2D,QAAQ,IAEjB3D,KAAK4D,GAASvE,EAEAW,KAAK6D,UAAU1E,EAAQI,IAEjCuE,QAAQC,MAAM,wBAID,MAAbzE,GACWU,KAAKgE,aAAwB1E,GAMvCU,KAAKsD,IAA2B,MAAlBtD,KAAKP,GAAmBO,KAAKiE,GAAiBjE,KAAKP,GAElEO,KAAKsD,GAILtD,KAAKyD,KAASzD,KAAKwC,GAAwBxC,KAAK0D,GAAQQ,iBAW5DlE,KAAKmE,GAAO,IAAIC,EAEhBpE,KAAKqE,GAAY,WAAQ,EAAKC,IAAmB,EACjDtE,KAAKuE,GAAe,SAACC,GAAQ,EAAKC,GAASD,EAAG,EAC9CxE,KAAK0E,GAAiB,SAACF,GAAQ,EAAKG,GAAWH,EAAG,CACtD,CACJ,OAj/DW,YAAAI,SAAP,WACI,OAAO5E,KAAK4D,EAChB,EA0BO,YAAAiB,cAAP,SAAqBC,EAAuBC,GACxC/E,KAAKL,EAAiBmF,EACtB9E,KAAKJ,EAAiBmF,EAEtB/E,KAAKH,EAAOC,KAAKC,GAAKC,KAAKL,EAAiB,IAC5CK,KAAKC,EAAOH,KAAKC,GAAKC,KAAKJ,EAAiB,GAChD,EAMO,YAAAoF,cAAP,SAAqBC,GACjBjF,KAAKE,EAAc+E,CACvB,EAEO,YAAAC,aAAP,SAAoBnH,GAChBiC,KAAKG,EAAWgF,KAAKC,MAAQrH,CACjC,EACO,YAAAsH,YAAP,SAAmBtH,GACfiC,KAAKG,EAAWmF,IAAIF,MAAQrH,CAChC,EACO,YAAAwH,aAAP,SAAoBxH,GAChBiC,KAAKG,EAAWqF,SAASJ,MAAQrH,CACrC,EACO,YAAA0H,iBAAP,SAAwB1H,GACpBiC,KAAKG,EAAWuF,aAAaN,MAAQrH,CACzC,EACO,YAAA4H,aAAP,SAAoB5H,GAChBiC,KAAKG,EAAWyF,SAASR,MAAQrH,EACjCiC,KAAKG,EAAW0F,QAAQT,MAAQrH,CACpC,EACO,YAAA+H,aAAP,SAAoB/H,GAChBiC,KAAKG,EAAW4F,WAAWX,MAAQrH,CACvC,EACO,YAAAiI,iBAAP,SAAwBjI,GACpBiC,KAAKG,EAAW8F,eAAeb,MAAQrH,CAC3C,EACO,YAAAmI,cAAP,SAAqBnI,GACjBiC,KAAKG,EAAWgG,YAAYf,MAAQrH,CACxC,EACO,YAAAqI,kBAAP,SAAyBrI,GACrBiC,KAAKG,EAAW8F,eAAeb,MAAQrH,CAC3C,EAGO,YAAAsI,aAAP,SAAoBtI,GAChBiC,KAAKG,EAAWmG,SAASlB,MAAQrH,EAAI+B,KAAKC,GAAK,IAC/CC,KAAKG,EAAWoG,UAAUnB,MAAQrH,EAAI+B,KAAKC,GAAK,GACpD,EACO,YAAAyG,iBAAP,SAAwBzI,GACpBiC,KAAKG,EAAWsG,aAAarB,MAAQrH,EAAI+B,KAAKC,GAAK,IACnDC,KAAKG,EAAWuG,cAActB,MAAQrH,EAAI+B,KAAKC,GAAK,GACxD,EACO,YAAA4G,WAAP,SAAkB5I,GACdiC,KAAKN,EAAW3B,CACpB,EAmBO,YAAA6I,mBAAP,SAA0BC,GACG,MAArB7G,KAAKgB,GAAwBhB,KAAKgB,EAAa8F,OAAO9G,KAAKgB,EAAa+F,GAAGC,OAC/EhH,KAAKsD,IAAQ,EACbtD,KAAKgE,aAAwB6C,EACjC,EAkBO,YAAAI,mBAAP,SAA0BC,GACtBlH,KAAKsD,IAAQ,EACbtD,KAAKgE,aAAwBkD,EACjC,EAmBO,YAAAlD,aAAP,SAAoBmD,GAMhB,IALA,IACIC,EADAP,GAAiB,EAKI,MADKvI,OAAO+I,KAAKrH,KAAKG,GACtB,eAAe,CAAnC,IAAImH,EAAY,KACbC,EAAYvH,KAAKG,EAAWmH,GAE1BC,aAAqBC,IAC3BD,EAAUT,OAAQ,EAKD,OAHjBM,EAAYD,EAASI,EAAUE,OAIvBL,aAAqB,EAAAM,gBACrBH,EAAUR,GAAKK,EACfG,EAAUI,KAAOJ,EAAUR,GAAGY,KAC9BJ,EAAUT,OAAQ,EAClBD,GAAQ,EACR7G,KAAKwD,IAAY,GACV4D,EAAUN,QACjB9G,KAAKwD,IAAY,EACjB+D,EAAUT,OAAQ,EACdM,aAAqB9I,QACjB8I,EAAUL,KACVQ,EAAUR,GAAKK,EAAUL,GACzBF,GAAQ,GAERO,EAAUO,OACVJ,EAAUI,KAAOP,EAAUO,MAET,MAAlBP,EAAUQ,OAAcL,EAAUK,KAAOR,EAAUQ,MACnDR,EAAUS,OAAMN,EAAUM,KAAOT,EAAUS,MAC3CT,EAAUhC,QAAOmC,EAAUnC,MAAQgC,EAAUhC,OAE7CgC,EAAUU,QAAOP,EAAUO,MAAQV,EAAUU,QAEjDP,EAAUI,KAAOP,I,CAQjC,OAHApH,KAAK+H,KAEL/H,KAAKgB,EAAe,KAChB6F,EAAc,KAAkB,IACxC,EAEO,YAAAmB,aAAP,WAII,IAHA,IAAIC,EAAiB,IAAI7H,EAGT,MADK9B,OAAO+I,KAAKrH,KAAKG,GACtB,eAAM,CAAjB,IAAI/B,EAAG,KACJ8J,EAAWlI,KAAKG,EAAW/B,GAE/B,GAAM8J,aAAoBV,GACrBU,EAASpB,MAAd,CAEA,IAAIqB,EAAuBF,EAAIC,EAAST,IACxCU,EAASpB,GAAKmB,EAASnB,GACvBoB,EAASR,KAAOO,EAASP,KACzBQ,EAASP,KAAOM,EAASN,KACzBO,EAASN,KAAOK,EAASL,KACzBM,EAAS/C,MAAQ8C,EAAS9C,MAC1B+C,EAAS/J,IAAM8J,EAAS9J,IACxB+J,EAASL,MAAQI,EAASJ,MAC1BK,EAASrB,MAAQoB,EAASpB,KAVG,C,CAajC,OAAOmB,CACX,EAEO,YAAAG,YAAP,WACI,IAAIC,EAAkB,IAAIC,EAmB1B,OAlBAD,EAAI9I,YAAcS,KAAKuI,gBACvBF,EAAIG,QAA4B,GAAlBxI,KAAKyI,UACnBJ,EAAIK,WAAa1I,KAAK2I,eACtBN,EAAIO,aAAe5I,KAAKM,EAAcuI,QACtCR,EAAIS,cAAgB9I,KAAKK,EACzBgI,EAAIU,aAAe/I,KAAKmD,GACxBkF,EAAIW,aAAehJ,KAAKkD,GACxBmF,EAAIY,QAAUjJ,KAAKN,EACnB2I,EAAIa,SAAWlJ,KAAKqD,GACpBgF,EAAItD,cAAgB/E,KAAKJ,EACzByI,EAAIvD,cAAgB9E,KAAKL,EACzB0I,EAAIc,cAAgBnJ,KAAKQ,EACzB6H,EAAIpD,WAAajF,KAAKE,EACtBmI,EAAIP,MAAQ9H,KAAKoJ,GACjBf,EAAIgB,UAAYrJ,KAAKsJ,GACrBjB,EAAIkB,UAAYvJ,KAAKR,EAAQ+J,UAC7BlB,EAAImB,gBAAkBxJ,KAAKR,EAAQgK,gBAE5BnB,CACX,EAEO,YAAAoB,YAAP,SAAmBpB,GACfrI,KAAK0J,eAAerB,EAAI9I,aACxBS,KAAK2D,QAAQ0E,EAAIG,QAAU,EAAI,GAC/BxI,KAAK2J,cAActB,EAAIK,YACvB1I,KAAK4J,gBAAgBvB,EAAIO,cACzB5I,KAAK6J,oBAAoBxB,EAAIS,eAC7B9I,KAAK8J,iBAAiBzB,EAAIU,cAC1B/I,KAAK+J,yBAAyB1B,EAAIW,cAClChJ,KAAK2G,WAAW0B,EAAIY,SACpBjJ,KAAKgK,eAAe3B,EAAIa,UACxBlJ,KAAK6E,cAAcwD,EAAIvD,cAAeuD,EAAItD,eAC1C/E,KAAKiK,iBAAiB5B,EAAIc,eAC1BnJ,KAAKgF,cAAcqD,EAAIpD,YACvBjF,KAAKkK,SAAS7B,EAAIP,OAClB9H,KAAKmK,eAAe9B,EAAIgB,WACxBrJ,KAAKR,EAAQ+J,UAAUlB,EAAIkB,UAC3BvJ,KAAKR,EAAQgK,gBAAgBnB,EAAImB,eAErC,EAEQ,YAAAY,GAAR,SAAiBC,EAAkBC,EAAoCzC,EAAeD,GAGlF,GAAK5H,KAAKsD,IAA2B,MAAlBtD,KAAKP,EAAxB,CAEA,GAAgB,MAAZ6K,EACA,GAAItK,KAAKsD,GAAO,CACZ,KAAMgH,aAAoB,EAAA5C,gBAAiB,OAC3C2C,EAAKtD,GAAqBuD,EAC1BD,EAAKvD,OAAQ,C,KACV,CACH,GAAmD,MAA/C9G,KAAKP,EAAU8K,kBAAkBF,EAAK1C,MAKtC,YADA0C,EAAKvD,OAAQ,GAHbuD,EAAK1C,KAAe2C,EACpBD,EAAKvD,OAAQ,C,CAQb,MAARc,IAAcyC,EAAKzC,KAAOA,GAClB,MAARC,IAAcwC,EAAKxC,KAAOA,EAnBmB,CAoBrD,EAEO,YAAAsC,eAAP,SAAsBpM,GAClB,GAAIiC,KAAKsD,GAEL,IADA,IACgB,MADKhF,OAAO+I,KAAKrH,KAAKG,GACtB,eAAM,CAAjB,IAAI/B,EAAG,KACJoM,EAAMxK,KAAKG,EAAW/B,GAC1B,GAAMoM,aAAehD,GACjBgD,EAAI1D,MAAO,CACX,IAAI2D,EAAqBD,EAAIzD,GAC7B/G,KAAKsJ,GAAavL,EAClB,IAAe,UAAA0M,EAAGC,mBAAH,eAAuB,CAAjC,IAAIC,EAAE,KACPA,EAAGC,UAAUT,gBAAiB,EAC9BQ,EAAGC,UAAUC,cAAgB9M,C,QAKlB,OAAnBiC,KAAKP,IACLO,KAAKP,EAAU0K,eAAepM,GAC9BiC,KAAKsJ,GAAavL,EAG9B,EAEO,YAAA+M,gBAAP,WACI,GAAI9K,KAAKsD,GAEL,IADA,IACgB,MADKhF,OAAO+I,KAAKrH,KAAKG,GACtB,eAAM,CAAjB,IAAI/B,EAAG,KACJiM,EAAOrK,KAAKG,EAAW/B,GAC3B,GAAMiM,aAAgB7C,GAClB6C,EAAKvD,MAEL,IADA,IACe,MADUuD,EAAKtD,GACZ2D,mBAAH,eAAuB,CAA3B,KACJE,UAAUT,gBAAiB,C,EAKlD,EAGO,YAAAY,YAAP,SAAmBC,EAAoCnD,EAAcD,GACjE5H,KAAKoK,GAASpK,KAAKG,EAAWgF,KAAM6F,EAAWnD,EAAMD,EACzD,EACO,YAAAqD,WAAP,SAAkBD,EAAoCnD,EAAcD,GAChE5H,KAAKoK,GAASpK,KAAKG,EAAWmF,IAAK0F,EAAWnD,EAAMD,EACxD,EACO,YAAAsD,gBAAP,SAAuBF,EAAoCnD,EAAcD,GACrE5H,KAAKoK,GAASpK,KAAKG,EAAWqF,SAAUwF,EAAWnD,EAAMD,GACzD5H,KAAKmL,GAAenL,KAAKG,EAAWuF,aAAc1F,KAAKG,EAAWqF,SACtE,EACO,YAAA4F,oBAAP,SAA2BJ,EAAoCnD,EAAcD,GACzE5H,KAAKoK,GAASpK,KAAKG,EAAWuF,aAAcsF,EAAWnD,EAAMD,EACjE,EACO,YAAAyD,iBAAP,SAAwBL,EAAoCnD,EAAcD,GACtE5H,KAAKoK,GAASpK,KAAKG,EAAWmL,UAAWN,EAAWnD,EAAMD,EAC9D,EACO,YAAA2D,YAAP,SAAmBP,EAAoCnD,EAAcD,GACjE5H,KAAKoK,GAASpK,KAAKG,EAAWqL,KAAMR,EAAWnD,EAAMD,EACzD,EACO,YAAA6D,iBAAP,SAAwBT,EAAoCnD,EAAcD,GACtE5H,KAAKoK,GAASpK,KAAKG,EAAWoG,UAAWyE,EAAWnD,EAAMD,GAC1D5H,KAAKmL,GAAenL,KAAKG,EAAWuG,cAAe1G,KAAKG,EAAWoG,UACvE,EACO,YAAAmF,qBAAP,SAA4BV,EAAoCnD,EAAcD,GAC1E5H,KAAKoK,GAASpK,KAAKG,EAAWuG,cAAesE,EAAWnD,EAAMD,EAClE,EACO,YAAA+D,gBAAP,SAAuBX,EAAoCnD,EAAcD,GACrE5H,KAAKoK,GAASpK,KAAKG,EAAWmG,SAAU0E,EAAWnD,EAAMD,GACzD5H,KAAKmL,GAAenL,KAAKG,EAAWsG,aAAczG,KAAKG,EAAWmG,SACtE,EACO,YAAAsF,oBAAP,SAA2BZ,EAAoCnD,EAAcD,GACzE5H,KAAKoK,GAASpK,KAAKG,EAAWsG,aAAcuE,EAAWnD,EAAMD,EACjE,EACO,YAAAiE,mBAAP,SAA0Bb,EAAoCnD,EAAcD,GACxE5H,KAAKoK,GAASpK,KAAKG,EAAWgG,YAAa6E,EAAWnD,EAAMD,GAC5D5H,KAAKmL,GAAenL,KAAKG,EAAW2L,gBAAiB9L,KAAKG,EAAWgG,YACzE,EACO,YAAA4F,uBAAP,SAA8Bf,EAAoCnD,EAAcD,GAC5E5H,KAAKoK,GAASpK,KAAKG,EAAW2L,gBAAiBd,EAAWnD,EAAMD,EACpE,EACO,YAAAoE,kBAAP,SAAyBhB,EAAoCnD,EAAcD,GACvE5H,KAAKoK,GAASpK,KAAKG,EAAW4F,WAAYiF,EAAWnD,EAAMD,GAC3D5H,KAAKmL,GAAenL,KAAKG,EAAW8F,eAAgBjG,KAAKG,EAAW4F,WACxE,EACO,YAAAkG,sBAAP,SAA6BjB,EAAoCnD,EAAcD,GAC3E5H,KAAKoK,GAASpK,KAAKG,EAAW8F,eAAgB+E,EAAWnD,EAAMD,EACnE,EACO,YAAAsE,gBAAP,SAAuBlB,EAAoCnD,EAAcD,GACrE5H,KAAKoK,GAASpK,KAAKG,EAAWyF,SAAUoF,EAAWnD,EAAMD,EAC7D,EACO,YAAAuE,eAAP,SAAsBnB,EAAoCnD,EAAcD,GACpE5H,KAAKoK,GAASpK,KAAKG,EAAW0F,QAASmF,EAAWnD,EAAMD,EAC5D,EACO,YAAAwE,YAAP,SAAmBpB,EAAoCnD,EAAcD,GACjE5H,KAAKoK,GAASpK,KAAKG,EAAWkM,KAAMrB,EAAWnD,EAAMD,EACzD,EAKO,YAAAsC,SAAP,SAAgBpC,GACZ,GAAa,MAATA,EAAJ,CACA9H,KAAKoJ,GAAatB,EAClB,IAAIwE,EAA0BhO,OAAO+I,KAAKrH,KAAKG,GAC/C2H,EAAMF,MAAO,EACb,IAAyB,UAAA0E,EAAA,eAAe,CAAnC,IAAIhF,EAAY,KACbC,EAAYvH,KAAKG,EAAWmH,GAE1BC,aAAqBC,IAC3BD,EAAUO,MAAQA,EAClBP,EAAUO,MAAMyE,aAAavM,KAAKR,G,CAEtCQ,KAAKG,EAAWqL,KAAK1D,MAAQ,KAC7B9H,KAAKG,EAAWkM,KAAKvE,MAAQ,KAC7B9H,KAAKG,EAAWmL,UAAUxD,MAAQ,IAbT,CAc7B,EAIO,YAAA0E,WAAP,SAAkBpO,GACd4B,KAAKG,EAAWgF,KAAK/G,IAAMA,EAAIqO,aACnC,EACO,YAAAC,eAAP,SAAsBtO,GAClB4B,KAAKG,EAAWqF,SAASpH,IAAMA,EAAIqO,aACvC,EACO,YAAAE,eAAP,SAAsBvO,GAClB4B,KAAKG,EAAWmG,SAASlI,IAAMA,EAAIqO,aACvC,EACO,YAAAG,gBAAP,SAAuBxO,GACnB4B,KAAKG,EAAWoG,UAAUnI,IAAMA,EAAIqO,aACxC,EACO,YAAAI,iBAAP,SAAwBzO,GACpB4B,KAAKG,EAAW4F,WAAW3H,IAAMA,EAAIqO,aACzC,EACO,YAAAK,kBAAP,SAAyB1O,GACrB4B,KAAKG,EAAWgG,YAAY/H,IAAMA,EAAIqO,aAC1C,EACO,YAAAM,WAAP,SAAkB3O,GACd4B,KAAKG,EAAWyF,SAASxH,IAAMA,EAAIqO,aACvC,EAEO,YAAA5C,oBAAP,SAA2BmD,GACvBhN,KAAKK,EAAiB2M,CAC1B,EAEO,YAAAlD,iBAAP,SAAwB/L,GACpBiC,KAAKmD,GAAgBpF,CACzB,EAEO,YAAAgM,yBAAP,SAAgCiD,GAC5BhN,KAAKkD,GAAiB8J,CAC1B,EACO,YAAApD,gBAAP,SAAuBqD,GACnBjN,KAAKM,EAAc4M,SAASD,EAChC,EAQO,YAAAE,uBAAP,WACInN,KAAKwC,GAAwBxC,KAAK0D,GAAQQ,eAC9C,EACO,YAAA+F,iBAAP,SAAwB+C,GACpBhN,KAAKQ,EAAiBwM,CAC1B,EASQ,YAAA/I,GAAR,SAAyBmJ,GAErB,IADA,IACgB,MADK9O,OAAO+I,KAAKrH,KAAKG,GACtB,eAAM,CAAjB,IAAI/B,EAAG,KACJiM,EAAOrK,KAAKG,EAAW/B,GACrBiM,aAAgB7C,IACV,MAAR4F,EACuC,MAAnCA,EAAK7C,kBAAkBF,EAAK5C,MAC5B4C,EAAK1C,KAAO0C,EAAK5C,GACjB4C,EAAKvD,OAAQ,EACb9G,KAAKwD,IAAY,GAGrB6G,EAAKvD,OAAQ,E,CAGrB9G,KAAK+H,IACT,EAKQ,YAAAA,GAAR,WACI/H,KAAKmL,GAAenL,KAAKG,EAAWuF,aAAc1F,KAAKG,EAAWqF,UAClExF,KAAKmL,GAAenL,KAAKG,EAAWuG,cAAe1G,KAAKG,EAAWoG,WACnEvG,KAAKmL,GAAenL,KAAKG,EAAWsG,aAAczG,KAAKG,EAAWmG,UAClEtG,KAAKmL,GAAenL,KAAKG,EAAW2L,gBAAiB9L,KAAKG,EAAWgG,aACrEnG,KAAKmL,GAAenL,KAAKG,EAAW8F,eAAgBjG,KAAKG,EAAW4F,WACxE,EAEQ,YAAAoF,GAAR,SAAuBkC,EAAeC,GAC9BD,EAAEvG,OACDwG,EAAExG,QACPuG,EAAEvG,OAAQ,EACVuG,EAAEtG,GAAKuG,EAAEvG,GACTsG,EAAE1F,KAAO2F,EAAE3F,KACX0F,EAAExF,KAAgB,EAATyF,EAAEzF,KACf,EAWO,YAAAlE,QAAP,SAAe5F,GAEPiC,KAAKyD,IACLzD,KAAKU,EAAQ3C,EACbiC,KAAKW,EAAY5C,IAEjBiC,KAAKU,EAAQ,EACbV,KAAKW,EAAY,EAEzB,EACO,YAAA8H,QAAP,WACI,OAAOzI,KAAKU,CAChB,EAWO,YAAAiJ,cAAP,SAAqBqD,GACjBhN,KAAKgC,EAASgL,CAClB,EACO,YAAArE,aAAP,WACI,OAAO3I,KAAKgC,CAChB,EAcQ,YAAAuL,GAAR,WACI,OAAIvN,KAAKR,EAAQgO,mBACNxN,KAAKR,EAAQgO,mBAAmBC,gBAAgBC,EAEpD1N,KAAKR,EAAQmO,SAASD,CACjC,EAEQ,YAAAE,GAAR,SAA4BC,GACxB,GAAI7N,KAAKR,EAAQgO,mBAAoB,CACjC,IAAMM,EAAQ9N,KAAKR,EAAQgO,mBAAmBC,gBAC9CK,EAAMJ,EAAIG,EACV7N,KAAKR,EAAQgO,mBAAqB,EAAAO,WAAA,qBAAgCD,EAAMJ,EAAGI,EAAME,EAAGF,EAAMG,E,MAE1FjO,KAAKR,EAAQmO,SAASD,EAAIG,CAElC,EAEQ,YAAAK,GAAR,SAA8BL,GAC1B,GAAI7N,KAAKR,EAAQgO,mBAAoB,CACjC,IAAMM,EAAQ9N,KAAKR,EAAQgO,mBAAmBC,gBAC9CK,EAAMJ,GAAKG,EACX7N,KAAKR,EAAQgO,mBAAqB,EAAAO,WAAA,qBAAgCD,EAAMJ,EAAGI,EAAME,EAAGF,EAAMG,E,MAE1FjO,KAAKR,EAAQmO,SAASD,GAAKG,CAEnC,EAIQ,YAAAM,GAAR,SAAgBC,GACZ,IAAMC,EAAqBD,EAAKE,iBAC1BC,EAAU,EAAAhO,QAAA,UAAkB8N,EAAWG,EAAG,GAC1CC,EAAU,EAAAlO,QAAA,UAAkB8N,EAAWG,EAAG,GAC1CE,EAAU,EAAAnO,QAAA,UAAkB8N,EAAWG,EAAG,GAC1CG,EAAU,EAAApO,QAAA,MAAcgO,EAASE,GAEnC,EAAAlO,QAAA,IAAYoO,EAASD,GAAW,GAChC1O,KAAKY,GAAa,EAClBZ,KAAKa,EAAe,IAGpBb,KAAKY,GAAa,EAClBZ,KAAKa,GAAgB,EAE7B,EAYO,YAAA6I,eAAP,SAAsBsD,GAClBhN,KAAK4O,GAAM5B,EAEXhN,KAAK6O,GAAW7O,KAAK4D,GAAOkL,sBAAwB,EAAI,EAIpD9O,KAAKY,GACLZ,KAAK+O,GAAU/B,EAAIlN,KAAKC,GAAK,EAAI,EAAID,KAAKC,GAAK,EAC/CC,KAAKgP,GAAUhC,EAAI,GAAK,IAExBhN,KAAK+O,GAAU/B,EAAI,EAAIlN,KAAKC,GAAK,EAAID,KAAKC,GAAK,EAC/CC,KAAKgP,GAAUhC,GAAK,EAAI,GAGvBhN,KAAKyD,KACNzD,KAAK+O,GAAU,EAIvB,EAEO,YAAAxG,cAAP,WACI,OAAOvI,KAAK4O,EAChB,EAEQ,YAAAK,SAAR,SAAiBpI,GAEb,IADA,IACgB,MADKvI,OAAO+I,KAAKrH,KAAKG,GACtB,eAAM,CAAjB,IAAI/B,EAAG,KACJiM,EAAOrK,KAAKG,EAAW/B,GACrBiM,aAAgB7C,IACE,MAApBX,EAAMwD,EAAK1C,QACX0C,EAAKtD,GAAKF,EAAMwD,EAAK1C,MACrB0C,EAAKvD,OAAQ,G,CAGzB,EAGQ,YAAAoI,GAAR,SAAoBC,EAAYC,EAAuBC,GACnD,IACIC,EAIAA,EAFAD,EACIrP,KAAKuP,GAASJ,GACXK,aAAY,SAACzR,GAAQ,OAAQA,aAAa,EAAA0R,aAAe,IAAG,GAG9D,CADDN,GAIR,IAAe,UAAAC,EAAA,eAEX,IAFC,IAEc,MAFR,KAC2B1E,mBACnB,eAAK,CAAf,IAAIC,EAAE,KACP,GAAI2E,EAAGI,QAAQ/E,EAAGgF,SAAW,EACzB,OAAO,C,CAInB,OAAO,CACX,EAGQ,YAAAJ,GAAR,SAAiBK,GACb,OAAiB,MAAbA,EAAGC,OAAuBD,EACvB5P,KAAKuP,GAASK,EAAGC,OAC5B,EAGO,YAAAC,MAAP,WACQ9P,KAAKc,IACTd,KAAKc,GAAW,EAChBd,KAAKmE,GAAK4L,QACV/P,KAAK6B,EAAe,EAEpB7B,KAAKqC,GAAgB,KACrBrC,KAAKmB,GAAY,EACjBnB,KAAKgQ,KACDhQ,KAAKqD,IAAMrD,KAAKiQ,KACpBjQ,KAAK4D,GAAOsM,qBAAqBlQ,KAAKqE,IAC1C,EAEO,YAAA2C,KAAP,WACShH,KAAKc,IACVd,KAAKc,GAAW,EAChBd,KAAK4D,GAAOuM,uBAAuBnQ,KAAKqE,IACxCrE,KAAKoQ,KACLpQ,KAAKgB,EAAe,KACxB,EASO,YAAAqP,UAAP,WACIrQ,KAAKe,GAAY,EAEQ,MAArBf,KAAKgB,GAAwBhB,KAAKgB,EAAa8F,QAE3C9G,KAAKsD,GACLtD,KAAKgB,EAAa+F,GAAGC,OAGrBhH,KAAK4D,GAAO0M,cAActQ,KAAKP,GAIJ,MAA3BO,KAAKgB,EAAa8G,OAClB9H,KAAKgB,EAAa8G,MAAMd,OAE5BuJ,cAAcvQ,KAAK0B,GAEnB1B,KAAK4D,GAAOuM,uBAAuBnQ,KAAKqE,IAEhD,EAOO,YAAAmM,WAAP,WACIxQ,KAAKe,GAAY,EACjBf,KAAKgB,EAAe,KACpBhB,KAAK4D,GAAOsM,qBAAqBlQ,KAAKqE,GAC1C,EAkBQ,YAAAoM,GAAR,WACI,OAAKzQ,KAAKyD,IACN,EAAAlD,QAAA,IAAYP,KAAKR,EAAQkR,QAAS1Q,KAAKR,EAAQmR,SAASC,SAAS5Q,KAAK0D,GAAQiN,WAAa,EAAU,GAD9E,CAG/B,EAEQ,YAAArM,GAAR,WACItE,KAAKiB,EAAYiM,SAASlN,KAAKR,EAAQmR,UACvC,IAAIE,EAAsB,KACpBC,EAAa9Q,KAAK4D,GAAOmN,YAAYC,eAAiB,IAc5D,GAZIhR,KAAKmE,GAAK8M,KAAUjR,KAAKqB,GACzBrB,KAAKmB,GAAY,EACjBnB,KAAKqC,GAAgB,EACrBwO,EAAU7Q,KAAKkR,GAAQJ,IAChB9Q,KAAKmR,eAAiBnR,KAAKqB,GAClCrB,KAAKmB,GAAY,EACjBnB,KAAKqC,GAAgB,EACrBwO,EAAU7Q,KAAKoR,GAAQN,IACf9Q,KAAKqB,IACbwP,EAAU7Q,KAAKqR,GAAQP,KAGtB9Q,KAAKe,GAAaf,KAAKwD,IAAwB,MAAXqN,GAEjC7Q,KAAKgB,IAAiB6P,EAAS,CAC/B,GAAIA,EAAQ/J,MAAO,CAGf,IAAIwK,OAAC,EACDC,EAAc,GAElB,GAAIvR,KAAKsD,GACoB,MAArBtD,KAAKgB,GAAwBhB,KAAKgB,EAAa8F,OAAO9G,KAAKgB,EAAa+F,GAAGC,OAC/E6J,EAAQ9J,GAAG+I,MAAMe,EAAQjJ,KAAMiJ,EAAQhJ,MACvC0J,EAAMV,EAAQ9J,GAAG2D,mBAAmB,GAAGE,UAAU4G,eACjDF,EAAKT,EAAQ9J,GAAG0K,GAAKZ,EAAQ9J,GAAG2K,UAGhCH,EADoBvR,KAAKP,EAAUkS,eAAed,EAAQlJ,KAAMkJ,EAAQjJ,KAAMiJ,EAAQhJ,MAC9E+J,gBAAgB,GAAGhH,UAAU4G,eACrCF,EAAItR,KAAKP,EAAU8K,kBAAkBsG,EAAQlJ,MAAM8J,GAAKzR,KAAKP,EAAU8K,kBAAkBsG,EAAQlJ,MAAM+J,KAKlF,MAArB1R,KAAKgB,GAAmD,MAA3BhB,KAAKgB,EAAa8G,OAC/C9H,KAAKgB,EAAa8G,MAAMd,OAE5BuJ,cAAcvQ,KAAK0B,GACE,MAAjBmP,EAAQ/I,QACR+I,EAAQ/I,MAAM+J,OAEd7R,KAAK0B,EAASoQ,aAAY,WAAQjB,EAAQ/I,MAAM+J,MAAQ,GAAO,IAAJP,GAAYC,EAAMzR,KAAKiS,IAAIlB,EAAQhJ,MAAQ,I,CAG9G7H,KAAKgB,EAAe6P,C,CAG5B7Q,KAAKgQ,IAET,EASQ,YAAAkB,GAAR,SAAgBJ,GAEZ,IAAID,EAAsB,KAC1BA,EAAU7Q,KAAKG,EAAW0F,QACH,IAAnB7F,KAAK4B,IACL5B,KAAK2B,EAAiB3B,KAAKR,EAAQmR,SAASjD,GAGhD1N,KAAK4B,EAAY5B,KAAK4B,EAAYkP,EAElC,IAEIkB,EAFAC,EAAsB,EACtBC,EAAmB,EAyBvB,GArBIlS,KAAKuB,GAAevB,KAAKsB,GACrBtB,KAAKuB,EACL0Q,EAAcjS,KAAKG,EAAWmF,IAAIF,MAAQ0L,EACnC9Q,KAAKsB,IACZ2Q,EAAcjS,KAAKG,EAAWgF,KAAKC,MAAQ0L,IAG/CkB,EAAOhS,KAAKwB,EAAYqH,SACnB6E,EAAI,GACTsE,EAAOA,EAAKG,aACPC,WAAWH,EAAaD,GAC7BE,EAAWlS,KAAKqS,GAAcrS,KAAKG,EAAW0F,QAAQT,MAAO0L,GAC7DkB,EAAKtE,EAAIwE,IAETA,EAAWlS,KAAKqS,GAAcrS,KAAKG,EAAWyF,SAASR,MAAO0L,GAC9DkB,EAAO,IAAI,EAAAzR,QAAQ,EAAG2R,EAAU,GAChCrB,EAAU7Q,KAAKG,EAAWyF,UAI9B5F,KAAKR,EAAQ8S,mBAAmBN,GAC5BE,EAAW,EAGX,GAAKlS,KAAKR,EAAQmR,SAASjD,EAAI1N,KAAKiB,EAAYyM,GAAQ1N,KAAKR,EAAQmR,SAASjD,IAAM1N,KAAKiB,EAAYyM,GAAOsE,EAAKO,SAAW,KACxHvS,KAAKwS,UACF,GAAIxS,KAAKR,EAAQmR,SAASjD,EAAI1N,KAAK2B,EAAgB,CAMtD,IAAM8Q,EAAmBzS,KAAKR,EAAQmR,SAASC,SAAS5Q,KAAKiB,GAC7D,GAAMjB,KAAK0S,GAAiBD,EAAST,EAAM,MASvCnB,EAAU7Q,KAAKG,EAAWkM,UALhBrM,KAAK2S,GAAcF,GACrBG,OAAS5S,KAAKH,GAClBG,KAAKwS,I,CAOrB,OAAO3B,CACX,EAEQ,YAAAwB,GAAR,SAAsBjN,EAAe0L,GAKjC,OAHiB1L,EAAQpF,KAAKN,EAAWM,KAAK4B,GAElBkP,EAAK,GAAM9Q,KAAKN,EAAWoR,EAAKA,CAEhE,EAKQ,YAAA0B,GAAR,WACIxS,KAAKmE,GAAK8M,IAAQ,EAClBjR,KAAK4B,EAAY,EACjB5B,KAAKsB,GAAc,EACnBtB,KAAKuB,GAAc,CACvB,EAKQ,YAAAmR,GAAR,SAAyBG,EAAaC,EAAaC,GAC/C,OAASjT,KAAKiS,IAAIc,EAAG7E,EAAI8E,EAAG9E,GAAK+E,GAAOjT,KAAKiS,IAAIc,EAAGnF,EAAIoF,EAAGpF,GAAKqF,GAAOjT,KAAKiS,IAAIc,EAAG5E,EAAI6E,EAAG7E,GAAK8E,CACnG,EAKQ,YAAAC,GAAR,SAAuB/F,GACnB,OAAOnN,KAAKmT,KAAKnT,KAAKiS,IAAI9E,EAAES,EAAI5N,KAAKoT,KAAKjG,EAAEe,EAAIf,EAAEe,EAAIf,EAAEgB,EAAIhB,EAAEgB,IAClE,EASQ,YAAAmD,GAAR,SAAgBN,GAIZ,IAAMqC,EAAanT,KAAKN,EAAWM,KAAK6B,EAIxC7B,KAAKoB,EAAgB+R,EAAIrC,EAAK9Q,KAAKN,EAAWoR,EAAKA,EAAK,EAExD9Q,KAAK6B,EAAe7B,KAAK6B,EAAeiP,EAExC,IAAIsC,GAAkB,EAClBC,EAAsB,KAqB1B,GAnBArT,KAAKwB,EAAYwM,EAAE,EACnBhO,KAAKwB,EAAYkM,EAAE,EACnB1N,KAAKwB,EAAYyM,EAAE,EAEfjO,KAAKqB,IACLrB,KAAKwB,EAAYkM,GAAK1N,KAAKoB,EAC3BgS,GAAS,GAKbpT,KAAKsT,KAGLD,EAAUrT,KAAKuT,GAAYF,EAASD,EAAQtC,IAKvC9Q,KAAKqB,EAAa,CACnBrB,KAAKsB,GAAc,EACnBtB,KAAKuB,GAAc,EAEnB,IAAIiS,OAAI,EACJC,EAAoB,EACxB,QAAQ,GACJ,KAAMzT,KAAKmE,GAAc,GAErBqP,EAAOxT,KAAKa,EAAeb,KAAKyQ,KAChCgD,EAAYzT,KAAKG,EAAW4F,WAAWX,MAAQ0L,EAC3C9Q,KAAKmE,GAAKuP,IACVD,EAAYzT,KAAKG,EAAW8F,eAAeb,MAAQ0L,EACnDuC,GAAYrT,KAAKgP,GAAUwE,EAAO,EAAKxT,KAAKG,EAAW8F,eAAiBjG,KAAKG,EAAW2L,iBAExFuH,GAAYrT,KAAKgP,GAAUwE,EAAO,EAAKxT,KAAKG,EAAW4F,WAAa/F,KAAKG,EAAWgG,YAExFnG,KAAKwB,EAAcxB,KAAKR,EAAQmU,YAAYH,EAAOC,GAAYzT,KAAKoB,EAAe,GACnFgS,GAAS,EACT,MACJ,KAAMpT,KAAKmE,GAAe,GAEtBqP,GAAQxT,KAAKa,EAAeb,KAAKyQ,KACjCgD,EAAYzT,KAAKG,EAAWgG,YAAYf,MAAQ0L,EAC5C9Q,KAAKmE,GAAKuP,IACVD,EAAYzT,KAAKG,EAAW2L,gBAAgB1G,MAAQ0L,EACpDuC,GAAYrT,KAAKgP,GAAUwE,EAAO,EAAKxT,KAAKG,EAAW8F,eAAiBjG,KAAKG,EAAW2L,iBAExFuH,GAAYrT,KAAKgP,GAAUwE,EAAO,EAAKxT,KAAKG,EAAW4F,WAAa/F,KAAKG,EAAWgG,YAExFnG,KAAKwB,EAAcxB,KAAKR,EAAQmU,YAAYH,EAAOC,GAAYzT,KAAKoB,EAAe,GACnFgS,GAAS,EACT,MACJ,KAAMpT,KAAKmE,GAAKyP,IAAU5T,KAAKgC,GAAwB,GAAdhC,KAAKU,EAEtCV,KAAKmE,GAAKuP,IACV1T,KAAKuB,GAAc,EACnBkS,EAAYzT,KAAKG,EAAWmF,IAAIF,MAAQ0L,EACxCuC,EAAUrT,KAAKG,EAAWmF,MAE1BtF,KAAKsB,GAAc,EACnBmS,EAAYzT,KAAKG,EAAWgF,KAAKC,MAAQ0L,EACzCuC,EAAUrT,KAAKG,EAAWgF,MAE9BnF,KAAKwB,EAAcxB,KAAKR,EAAQmU,YAAY,GAAI3T,KAAKoB,EAAepB,KAAKgP,GAAUyE,GACnFL,GAAS,EACT,MACJ,KAAMpT,KAAKmE,GAAc,GAErBsP,EAAYzT,KAAKG,EAAWqF,SAASJ,MAAQ0L,EACzC9Q,KAAKmE,GAAKuP,IACVD,EAAYzT,KAAKG,EAAWuF,aAAaN,MAAQ0L,EACjDuC,EAAUrT,KAAKG,EAAWuF,cAE1B2N,EAAUrT,KAAKG,EAAWqF,SAE9BxF,KAAKwB,EAAcxB,KAAKR,EAAQmU,YAAY,GAAI3T,KAAKoB,GAAgBpB,KAAKgP,GAAUyE,GACpFL,GAAS,E,CAMrB,GAAIA,GACIpT,KAAKwB,EAAY+Q,SAAW,KAAO,CACnCvS,KAAKR,EAAQ8S,mBAAmBtS,KAAKwB,GAErC,IAAIiR,EAAmBzS,KAAKR,EAAQmR,SAASC,SAAS5Q,KAAKiB,GAErD4S,EAAM7T,KAAK2S,GAAcF,GAG/B,GAAIzS,KAAKR,EAAQmR,SAASjD,EAAI1N,KAAKiB,EAAYyM,EAAI,IAI/C,GAAImG,EAAIC,KAAoB,GAAbD,EAAIjB,MAAa,CAG5B,GAAI5S,KAAKE,EAAc,EAIF2T,EAAInG,EAAI1N,KAAKiB,EAAYyM,EAGzB1N,KAAKE,EAClBF,KAAKkC,IAAY,EAEjBlC,KAAKkC,IAAY,EAKhBlC,KAAKkC,GAENlC,KAAKR,EAAQmR,SAASzD,SAASlN,KAAKiB,IAEpCjB,KAAKR,EAAQmR,SAASjD,EAAImG,EAAInG,EAC9B1N,KAAK6B,EAAe,E,KAGzB,CAEH,IAAMkS,EAAOF,EAAIjB,MAiBbmB,GAAQ/T,KAAKC,GAAQ4T,EAAInG,EAAI1N,KAAKkB,GAGlClB,KAAKR,EAAQmR,SAASzD,SAASlN,KAAKiB,GACpCjB,KAAKgU,KACLhU,KAAKkB,EAAa,IAGlBlB,KAAKkB,EAAa2S,EAAInG,EAClBqG,EAAO/T,KAAKH,EAEZG,KAAKqB,GAAc,EAGnBrB,KAAKgU,K,MAKd,GAAKhU,KAAKR,EAAQmR,SAASjD,EAAI1N,KAAKiB,EAAYyM,EAAI,CAGvD,IAAM,EAAmB1N,KAAKR,EAAQmR,SAASC,SAAS5Q,KAAKiB,GASzDjB,KAAK0S,GAAiB,EAAS1S,KAAKwB,EAAa,QAAYqS,EAAIC,KAEjE9T,KAAKqB,GAAc,EACnBgS,EAAUrT,KAAKG,EAAWkM,OAQlBwH,EAAIjB,MAAS5S,KAAKH,EAElBG,KAAKqB,GAAc,E,MAS/BrB,KAAKqB,GAAc,C,CAI/B,OAAOgS,CACX,EAKQ,YAAAV,GAAR,SAAsBF,GAAtB,IASQwB,EATR,OAEQC,EAASlU,KAAKR,EAAQmR,SAASjD,EAAI1N,KAAKiB,EAAYyM,EACpDyG,GAAa,GAEbA,EADArU,KAAKiS,IAAImC,GAAU,MAGbA,EAAS,IAGnBzB,EAAQ/E,EAAI,EACK,GAAb+E,EAAQzE,GAAuB,GAAbyE,EAAQxE,GAC1BgG,GAAM,EAGNA,EADe,EAAA1T,QAAA,IAAYP,KAAKR,EAAQkR,QAAS+B,EAAQN,cACtC,EAEvB,IAAIiC,EAAQD,GAAMF,IAAUE,IAAOF,EAAO,GAAK,EAgB/CjU,KAAKR,EAAQkR,QAAQ0B,WAAWpS,KAAKR,EAAQ+J,UAAUyE,EAAIoG,EAAMpU,KAAK4C,GAAKyR,QAC3ErU,KAAK4C,GAAKyR,OAAOC,SAAStU,KAAKR,EAAQmR,SAAU3Q,KAAK4C,GAAKyR,QAC3DrU,KAAK4C,GAAKyR,OAAOC,SAAStU,KAAKR,EAAQgK,gBAAiBxJ,KAAK4C,GAAKyR,QAKlErU,KAAK4C,GAAK2P,OAAmC,EAA1BvS,KAAKR,EAAQ+J,UAAUmE,EAE1C1N,KAAK4C,GAAK2R,UAAYvU,KAAKS,EAGL,MAAlBT,KAAKuD,IACLvD,KAAKwU,GAAWxU,KAAK4C,GAAKyR,OAAQrU,KAAK4C,GAAKyR,OAAOI,IAAI,IAAI,EAAAlU,QAAQ,GAAIP,KAAK4C,GAAK2P,OAAQ,KAM7F,IAAMmC,EAAkB1U,KAAK4D,GAAO+Q,YAAY3U,KAAK4C,IAAM,SAACwL,GACxD,OAAI,EAAKwG,GAAYC,SAASzG,MAC1BA,EAAKlK,eAEb,IAEA,GAAU,MAANwQ,GAAcA,EAAGZ,IAAK,CACtB,IAAI/V,EAAa2W,EAAGI,WAAU,GAAM,GAChClC,EAAgB9S,KAAKC,GAAK,EAAID,KAAKiV,KAAKjV,KAAKiS,IAAIhU,EAAE2P,IACvD,MAAO,CAAE,KAAQgH,EAAGM,WAAWrN,KAAM,QAAU,EAAM,MAASiL,EAAO,EAAI8B,EAAGO,YAAYvH,EAAG,KAAM,E,CAEhG,MAAO,CAAE,KAAQ,GAAI,QAAU,EAAO,MAAS,EAAG,EAAI,EAAG,KAAM,EAExE,EAIQ,YAAAwH,GAAR,sBAIIlV,KAAKR,EAAQmR,SAAS2D,SAAStU,KAAKR,EAAQgK,gBAAiBxJ,KAAK4C,GAAKyR,QACvErU,KAAK4C,GAAKyR,OAAO3G,EAAI1N,KAAK4C,GAAKyR,OAAO3G,EAAI1N,KAAKR,EAAQ+J,UAAUmE,EAEjE1N,KAAK4C,GAAK2P,OAASvS,KAAKR,EAAQ+J,UAAUmE,EAAI,EAE9C1N,KAAK4C,GAAK2R,UAAYvU,KAAKS,EAO3B,IAAM0U,EAAqBnV,KAAK4D,GAAOwR,iBAAiBpV,KAAK4C,IAAM,SAACwL,GAChE,OAAIA,GAAQ,EAAK5O,KACb4O,EAAKlK,eAEb,IAEA,GAAIiR,EAAI5C,OAAS,EAAG,CAChB,IAAImC,EAAkBS,EAAI,GAEtBpX,EAAa2W,EAAGI,WAAU,GAAM,GAChClC,EAAgB9S,KAAKC,GAAK,EAAID,KAAKiV,KAAKjV,KAAKiS,IAAIhU,EAAE2P,IAEvD,MAAO,CAAE,KAAQgH,EAAGM,WAAWrN,KAAM,QAAU,EAAM,MAASiL,E,CAE7D,MAAO,CAAE,KAAQ,GAAI,QAAU,EAAO,MAAS,EAExD,EAMQ,YAAA4B,GAAR,SAAmBa,EAAcC,GAC7B,GAAqB,MAAjBtV,KAAKmC,GAAiB,CACtB,IAAMoT,EAAW,CAACF,EAAKC,GACvBtV,KAAKoC,GAAe,CAChBoT,OAAQD,EACRE,WAAW,GAEfzV,KAAKmC,GAAW,EAAAuT,YAAA,YAAwB,QAAS1V,KAAKoC,G,MAEtDpC,KAAKoC,GAAaoT,OAAO,GAAGH,EAC5BrV,KAAKoC,GAAaoT,OAAO,GAAGF,EAC5BtV,KAAKoC,GAAauT,SAAW3V,KAAKmC,GAClCnC,KAAKmC,GAAW,EAAAuT,YAAA,YAAwB,QAAS1V,KAAKoC,GAE9D,EAKQ,YAAAkR,GAAR,WACI,GAAItT,KAAKyD,IACa,GAAdzD,KAAKU,EAAY,CACjB,IAAIkV,EAAM5V,KAAY,GAAKA,KAAK+O,GAAU/O,KAAK0D,GAAQmS,MAAS,EAChE,GAAI7V,KAAKgC,EACL,QAAQ,GACJ,KAAMhC,KAAKmE,GAAKyP,IAAS5T,KAAKmE,GAAK2R,GAC/B9V,KAAK4N,GAAoBgI,EAAK5V,KAAK6O,GAAW/O,KAAKC,GAAK,GACxD,MACJ,KAAMC,KAAKmE,GAAKyP,IAAS5T,KAAKmE,GAAK4R,GAC/B/V,KAAK4N,GAAoBgI,EAAK5V,KAAK6O,GAAW/O,KAAKC,GAAK,GACxD,MACJ,KAAMC,KAAKmE,GAAK6R,IAAahW,KAAKmE,GAAK2R,GACnC9V,KAAK4N,GAAoBgI,EAAqB,EAAhB5V,KAAK6O,GAAe/O,KAAKC,GAAK,GAC5D,MACJ,KAAMC,KAAKmE,GAAK6R,IAAahW,KAAKmE,GAAK4R,GACnC/V,KAAK4N,GAAoBgI,EAAqB,EAAhB5V,KAAK6O,GAAe/O,KAAKC,GAAK,GAC5D,MACJ,KAAMC,KAAKmE,GAAU,GACjBnE,KAAK4N,GAAoBgI,GACzB,MACJ,KAAM5V,KAAKmE,GAAc,GACrBnE,KAAK4N,GAAoBgI,EAAK9V,KAAKC,IACnC,MACJ,KAAMC,KAAKmE,GAAe,GACtBnE,KAAK4N,GAAoBgI,EAAK5V,KAAK6O,GAAW/O,KAAKC,GAAK,GACxD,MACJ,KAAMC,KAAKmE,GAAc,GACrBnE,KAAK4N,GAAoBgI,EAAK5V,KAAK6O,GAAW/O,KAAKC,GAAK,QAI5DC,KAAKyD,IACLzD,KAAK4N,GAAoBgI,E,CAG7C,EAGQ,YAAArC,GAAR,SAAoBlJ,EAAkB+I,EAAiBtC,GACnD,KAAM9Q,KAAKgC,GAAwB,GAAdhC,KAAKU,KAAiBV,KAAKmE,GAAK8R,KAAcjW,KAAKmE,GAAK+R,KAAgBlW,KAAKmE,GAAK4R,IAAa/V,KAAKmE,GAAK2R,IAAa,CACvI,IAAIK,EAAYnW,KAAKG,EAAWmG,SAASlB,MAAQ0L,EAC7C9Q,KAAKmE,GAAKuP,KACVyC,GAAY,GAEhB,IAAI9Y,OAAC,EACa,GAAd2C,KAAKU,GAGAV,KAAK+B,IAGN/B,KAAK8B,GAAS9B,KAAKgP,GAAUhP,KAAKyQ,KAC9BzQ,KAAKY,IAAYZ,KAAK8B,GAAU9B,KAAK8B,GACzC9B,KAAK+B,GAAa,GAEtB1E,EAAI2C,KAAK8B,EACL9B,KAAKmE,GAAK4R,GACN/V,KAAKmE,GAAKyP,KACL5T,KAAKmE,GAAK6R,GAAW3Y,GAAK2C,KAAK8B,EAEpCuI,EAAQrK,KAAK8B,EAAQ,EAAK9B,KAAKG,EAAWoG,UAAYvG,KAAKG,EAAWmG,UAGtEtG,KAAKmE,GAAKyP,GAAOvW,GAAK2C,KAAK8B,EACtB9B,KAAKmE,GAAK6R,KAEf3Y,GAAK2C,KAAK8B,EACVuI,EAAQrK,KAAK8B,EAAQ,EAAK9B,KAAKG,EAAWmG,SAAWtG,KAAKG,EAAWoG,aAI7ElJ,EAAI,EACA2C,KAAKmE,GAAK4R,IACN/V,KAAKmE,GAAK6R,KAAW3Y,GAAK,GACzB+V,IAAQ/I,EAAOrK,KAAKG,EAAWmG,YAEhCtG,KAAKmE,GAAKyP,KAAOvW,GAAK,GACrB+V,IAAU/V,GAAK,EAAGgN,EAAOrK,KAAKG,EAAWoG,YAE9CvG,KAAKyD,KACLzD,KAAK0D,GAAQmS,MAAQ7V,KAAK0D,GAAQmS,MAAQ7V,KAAK6O,GAAWsH,EAAY9Y,IAE9E2C,KAAKkO,GAAsBiI,EAAY9Y,E,CAE3C,OAAOgN,CACX,EAEQ,YAAA2J,GAAR,WACIhU,KAAK6B,EAAe,EACpB7B,KAAKqB,GAAc,CACvB,EAIQ,YAAAgQ,GAAR,SAAgBP,GACZ,GAAI9Q,KAAKmB,EACL,OAAOnB,KAAKG,EAAWqL,KAE3BxL,KAAKsB,GAAc,EACnBtB,KAAKuB,GAAc,EACnBvB,KAAK6B,EAAe,EACpB,IAAIwI,EAAmBrK,KAAKG,EAAWqL,KAEvC,GAAW,IAAPsF,EACA9Q,KAAKoB,EAAgB,MAClB,CACH,IAAM+R,EAAYnT,KAAKqC,GAAgBrC,KAAKN,EAC5CM,KAAKoB,EAAgB+R,EAAIrC,EAAK9Q,KAAKN,EAAWoR,EAAKA,EAAK,EACxD9Q,KAAKqC,GAAgBrC,KAAKqC,GAAgByO,C,CAI9C,GAAI9Q,KAAKoB,EAAgB,IAAM,OAAOiJ,EACtC,IAAM2H,EAAgB,IAAI,EAAAzR,QAAQ,GAAIP,KAAKoB,EAAe,GAG1D,GADApB,KAAKR,EAAQ8S,mBAAmBN,GAC3BhS,KAAKR,EAAQmR,SAASjD,EAAI1N,KAAKiB,EAAYyM,GAAO1N,KAAKR,EAAQmR,SAASjD,IAAM1N,KAAKiB,EAAYyM,EAAI,CAGpG,IAAM+E,EAAmBzS,KAAKR,EAAQmR,SAASC,SAAS5Q,KAAKiB,GACpDjB,KAAK2S,GAAcF,GAErBG,OAAS5S,KAAKH,GACjBG,KAAKoW,KACLpW,KAAKR,EAAQmR,SAASzD,SAASlN,KAAKiB,KAEpCjB,KAAKqW,KACLhM,EAAOrK,KAAKG,EAAWmL,U,MAIxB,GAAItL,KAAKR,EAAQmR,SAASjD,EAAI1N,KAAKiB,EAAYyM,EAAG,CAM/C+E,EAAmBzS,KAAKR,EAAQmR,SAASC,SAAS5Q,KAAKiB,GAC7D,GAAMjB,KAAK0S,GAAiBD,EAAST,EAAM,MAavC3H,EAAOrK,KAAKG,EAAWkM,UATdrM,KAAK2S,GAAcF,GACrBG,OAAS5S,KAAKH,GACjBG,KAAKoW,KACLpW,KAAKR,EAAQmR,SAASzD,SAASlN,KAAKiB,KAEpCjB,KAAKqW,KACLhM,EAAOrK,KAAKG,EAAWmL,U,CAMnC,OAAOjB,CACX,EAQQ,YAAA+L,GAAR,WACIpW,KAAKsC,KACDtC,KAAKsC,GAAoBtC,KAAKuC,KAC9BvC,KAAKmB,GAAY,EACjBnB,KAAKqC,GAAgB,EAE7B,EACQ,YAAAgU,GAAR,WACIrW,KAAKmB,GAAY,EACjBnB,KAAKsC,GAAoB,CAC7B,EAIQ,YAAA0N,GAAR,WACShQ,KAAKyD,KAEVzD,KAAKR,EAAQmR,SAAS2D,SAAStU,KAAKM,EAAeN,KAAK0D,GAAQiM,QAE5D3P,KAAK0D,GAAQ4S,OAAStW,KAAK0D,GAAQ6S,mBAAwBvW,KAAKK,GAAkBL,KAAKkD,KAAgBlD,KAAKwW,KAG5GxW,KAAK0D,GAAQ4S,QAAUtW,KAAK0D,GAAQ6S,iBAC/BvW,KAAKQ,GAAmBR,KAAKyC,KAC9BzC,KAAKyW,GAAmBzW,KAAKR,GAC7BQ,KAAK0D,GAAQQ,iBAAkB,EAC/BlE,KAAKW,EAAYX,KAAKU,EACtBV,KAAKU,EAAQ,EACbV,KAAKyC,IAAQ,GAGbzC,KAAKyC,KACLzC,KAAKyC,IAAQ,EACbzC,KAAKU,EAAQV,KAAKW,EAClBX,KAAK0W,GAAkB1W,KAAKR,GAC5BQ,KAAK0D,GAAQQ,gBAAkBlE,KAAKwC,IAGhD,EAIQ,YAAAiU,GAAR,SAA2BrI,GAA3B,WAEIpO,KAAK0C,GAAciU,IAAIvI,EAAMA,EAAKwI,YAClCxI,EAAKwI,WAAa,EAElBxI,EAAKyI,gBAAe,GAAO,SAAC9Y,GAKxB,OAJIA,aAAa,EAAA+Y,OACb,EAAKpU,GAAciU,IAAI5Y,EAAGA,EAAE6Y,YAC5B7Y,EAAE6Y,WAAa,IAEZ,CACX,GACJ,EAKQ,YAAAF,GAAR,SAA0BtI,GAA1B,WACIA,EAAKwI,WAAa5W,KAAK0C,GAAcjE,IAAI2P,GACzCA,EAAKyI,gBAAe,GAAO,SAAC9Y,GAExB,OADIA,aAAa,EAAA+Y,OAAM/Y,EAAE6Y,WAAa,EAAKlU,GAAcjE,IAAIV,KACtD,CACX,GACJ,EAwBQ,YAAAyY,GAAR,sBAGIxW,KAAK0D,GAAQiN,SAASoG,cAAc/W,KAAK0D,GAAQiM,OAAQ3P,KAAK8C,IAE9D9C,KAAK4C,GAAKyR,OAASrU,KAAK0D,GAAQiM,OAChC3P,KAAK4C,GAAK2P,OAASvS,KAAK8C,GAAQyP,SAChCvS,KAAK4C,GAAK2R,UAAYvU,KAAK8C,GAAQqP,YAInC,IAAMgD,EAAqBnV,KAAK4D,GAAOwR,iBAAiBpV,KAAK4C,IAAM,SAACwL,GAChE,OAAI,EAAKwG,GAAYC,SAASzG,MAC1BA,EAAK4I,UAKb,IAGA,GAAIhX,KAAKkD,GAEL,GADAlD,KAAKiX,GAAoBjX,KAAKgD,GAC1BmS,EAAI5C,OAAS,EAAG,CAChBvS,KAAKgD,GAAgB,IAAIC,MACzB,IAAe,UAAAkS,EAAA,eAAK,CAAf,IAAIT,EAAE,MACHA,EAAGM,WAAWkC,WAAalX,KAAKiX,GAAkBpC,SAASH,EAAGM,eAC9DN,EAAGM,WAAWkC,WAAY,EAC1BlX,KAAKgD,GAAcmU,KAAKzC,EAAGM,Y,CAGnC,IAAe,UAAAhV,KAAKiX,GAAL,eAAwB,CAAlC,IAAIG,EAAE,KACFpX,KAAKgD,GAAc6R,SAASuC,KAC7BA,EAAGF,WAAY,E,MAGpB,CACH,IAAe,UAAAlX,KAAKiX,GAAL,eAAwB,EAA9BG,EAAE,MACJF,WAAY,C,CAEnBlX,KAAKiX,GAAkB1E,OAAS,C,CAIxC,GAAIvS,KAAKK,GACD8U,EAAI5C,OAAS,EAAG,CAIhB,KAAmB,GAAd4C,EAAI5C,QAAgBvS,KAAKqX,GAAWlC,EAAI,GAAGH,aAAkBG,EAAI,GAAGH,WAAW9Q,iBAAoBlE,KAAK0D,GAAQQ,iBAAkB,OAOvI,IAJA,IAAIoT,EAAc,KAITha,EAAI,EAAGA,EAAI6X,EAAI5C,OAAQjV,IAAK,CAC7B8Z,EAAKjC,EAAI7X,GAAG0X,WAChB,GAAIhV,KAAKqX,GAAWD,GAAK,CACrBE,EAAKnC,EAAI7X,GAAG2X,YACZ,K,CACG,GAAImC,EAAGlT,gBAAiB,CAC3BoT,EAAKnC,EAAI7X,GAAG2X,YACZ,K,EAGR,GAAU,MAANqC,EAAY,OAEhB,IAAMC,EAAevX,KAAK0D,GAAQiN,SAASC,SAAS0G,GAU9CE,EAAYD,EAAIhF,SACtB,GAAIvS,KAAK0D,GAAQQ,gBAAiB,CAC9B,IAAIuT,OAAI,EAEJA,EADAD,GAAK,EACED,EAAIG,WAAWH,EAAII,iBAAiBC,aAAa5X,KAAK+C,KAEtDwU,EAAIpF,YAAYyF,aAAaJ,EAAIxX,KAAKmD,IAEjDnD,KAAK0D,GAAQiN,SAAW3Q,KAAK0D,GAAQiN,SAASC,SAAS6G,E,KACpD,CACCA,OAAI,EACIA,EAARD,GAAK,EAAUA,EAAIxX,KAAK+C,GAAyByU,EAAIxX,KAAKmD,GAC9DnD,KAAK0D,GAAQ4S,OAAStW,KAAK0D,GAAQ4S,OAAS,C,EAI5D,EAGQ,YAAAe,GAAR,SAAmBjJ,GACf,QAAKA,EAAK8I,YACa,GAAnB9I,EAAKwI,aACY,MAAjBxI,EAAKyJ,UAA+C,GAA3BzJ,EAAKyJ,SAASC,WAAyC,GAAvB1J,EAAKyJ,SAAShC,OAG/E,EAIO,YAAA1E,YAAP,WACI,OAAQnR,KAAKmE,GAAKyP,IAAS5T,KAAKmE,GAAK6R,IAAahW,KAAKmE,GAAK4R,IAAa/V,KAAKmE,GAAK2R,IAAc9V,KAAKmE,GAAK8R,IAAajW,KAAKmE,GAAK+R,EACtI,EAEQ,YAAAvR,GAAR,SAAmBH,GACf,GAAKA,EAAEpG,MACHoG,EAAEuT,OAAN,CACA,OAAQvT,EAAEpG,IAAIqO,eACV,KAAKzM,KAAKG,EAAWyF,SAASxH,IAC1B4B,KAAKmE,GAAK8M,IAAQ,EAClB,MACJ,IAAK,WACDjR,KAAKmE,GAAKuP,IAAa1T,KAAKmE,GAAKuP,GACjC,MACJ,IAAK,QACD1T,KAAKmE,GAAKuP,IAAY,EACtB,MACJ,IAAK,KACL,IAAK,UACL,KAAK1T,KAAKG,EAAWgF,KAAK/G,IAEtB4B,KAAKmE,GAAKyP,IAAQ,EAClB,MACJ,IAAK,OACL,IAAK,YACL,KAAK5T,KAAKG,EAAWmG,SAASlI,IAE1B4B,KAAKmE,GAAK4R,IAAY,EACtB,MACJ,IAAK,QACL,IAAK,aACL,KAAK/V,KAAKG,EAAWoG,UAAUnI,IAE3B4B,KAAKmE,GAAK2R,IAAa,EACvB,MACJ,IAAK,OACL,IAAK,YACL,KAAK9V,KAAKG,EAAWqF,SAASpH,IAE1B4B,KAAKmE,GAAK6R,IAAY,EACtB,MACJ,KAAKhW,KAAKG,EAAW4F,WAAW3H,IAE5B4B,KAAKmE,GAAK8R,IAAY,EACtB,MACJ,KAAKjW,KAAKG,EAAWgG,YAAY/H,IAE7B4B,KAAKmE,GAAK+R,IAAa,EAG/BlW,KAAKoD,GAAQpD,KAAKmR,aA5CE,CA6CxB,EAEQ,YAAA1M,GAAR,SAAiBD,GACb,GAAKA,EAAEpG,IAAP,CACA,OAAQoG,EAAEpG,IAAIqO,eACV,IAAK,QACDzM,KAAKmE,GAAKuP,IAAY,EACtB,MACJ,IAAK,KACL,IAAK,UACL,KAAK1T,KAAKG,EAAWgF,KAAK/G,IACtB4B,KAAKmE,GAAKyP,IAAQ,EAClB,MACJ,IAAK,OACL,IAAK,YACL,KAAK5T,KAAKG,EAAWmG,SAASlI,IAC1B4B,KAAKmE,GAAK4R,IAAY,EACtB/V,KAAK+B,GAAa,EAClB,MACJ,IAAK,QACL,IAAK,aACL,KAAK/B,KAAKG,EAAWoG,UAAUnI,IAC3B4B,KAAKmE,GAAK2R,IAAa,EACvB9V,KAAK+B,GAAa,EAClB,MACJ,IAAK,OACL,IAAK,YACL,KAAK/B,KAAKG,EAAWqF,SAASpH,IAC1B4B,KAAKmE,GAAK6R,IAAY,EACtB,MACJ,KAAKhW,KAAKG,EAAW4F,WAAW3H,IAC5B4B,KAAKmE,GAAK8R,IAAY,EACtB,MACJ,KAAKjW,KAAKG,EAAWgG,YAAY/H,IAC7B4B,KAAKmE,GAAK+R,IAAa,EAG/BlW,KAAKoD,GAAQpD,KAAKmR,aAlCA,CAmCtB,EAGO,YAAA6G,kBAAP,WACI,OAAOhY,KAAKqD,EAChB,EACO,YAAA2G,eAAP,SAAsBgD,GAClBhN,KAAKqD,GAAO2J,EACRA,EACAhN,KAAKiQ,KAELjQ,KAAKoQ,IAEb,EAEQ,YAAAH,GAAR,WACI,IAAIgI,EAA4BjY,KAAK4D,GAAOmN,YAAYmH,qBACxDD,EAAOE,iBAAiB,QAASnY,KAAKuE,IAAc,GACpD0T,EAAOE,iBAAiB,UAAWnY,KAAK0E,IAAgB,EAC5D,EAEQ,YAAA0L,GAAR,WACI,IAAI6H,EAA4BjY,KAAK4D,GAAOmN,YAAYmH,qBACxDD,EAAOG,oBAAoB,QAASpY,KAAKuE,IAAc,GACvD0T,EAAOG,oBAAoB,UAAWpY,KAAK0E,IAAgB,EAC/D,EAGO,YAAAS,KAAP,SAAY6H,GACRhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAKyP,GAAQ5G,CACtB,EACO,YAAAxH,SAAP,SAAgBwH,GACZhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK6R,GAAYhJ,CAC1B,EACO,YAAAtH,aAAP,SAAoBsH,GAChBhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK6R,GAAYhJ,EACtBhN,KAAKmE,GAAKuP,GAAY1G,CAC1B,EACO,YAAA1H,IAAP,SAAW0H,GACPhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAKyP,GAAQ5G,EAClBhN,KAAKmE,GAAKuP,GAAY1G,CAC1B,EACO,YAAA1G,SAAP,SAAgB0G,GACZhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK4R,GAAY/I,EACjBA,IAAGhN,KAAK+B,EAAaiL,EAC9B,EACO,YAAAvG,aAAP,SAAoBuG,GAChBhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK4R,GAAY/I,EACjBA,IAAGhN,KAAK+B,EAAaiL,GAC1BhN,KAAKmE,GAAKuP,GAAY1G,CAC1B,EACO,YAAAzG,UAAP,SAAiByG,GACbhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK2R,GAAa9I,EAClBA,IAAGhN,KAAK+B,EAAaiL,EAC9B,EACO,YAAAtG,cAAP,SAAqBsG,GACjBhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK2R,GAAa9I,EAClBA,IAAGhN,KAAK+B,EAAaiL,GAC1BhN,KAAKmE,GAAKuP,GAAY1G,CAC1B,EACO,YAAAjH,WAAP,SAAkBiH,GACdhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK8R,GAAYjJ,CAC1B,EACO,YAAA/G,eAAP,SAAsB+G,GAClBhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK8R,GAAYjJ,EACtBhN,KAAKmE,GAAKuP,GAAY1G,CAC1B,EACO,YAAA7G,YAAP,SAAmB6G,GACfhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK+R,GAAalJ,CAC3B,EACO,YAAAlB,gBAAP,SAAuBkB,GACnBhN,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK+R,GAAalJ,EACvBhN,KAAKmE,GAAKuP,GAAY1G,CAC1B,EACO,YAAAqL,KAAP,WACIrY,KAAKmE,GAAK4L,QACV/P,KAAKmE,GAAK8M,IAAQ,CACtB,EAEO,YAAA5E,KAAP,WACIrM,KAAKmE,GAAK4L,QACV/P,KAAKmB,GAAY,CACrB,EAEO,YAAAqK,KAAP,WACIxL,KAAKmE,GAAK4L,OACd,EAOO,YAAAuI,KAAP,WACI,OAAOtY,KAAKsD,EAChB,EAKQ,YAAAiV,GAAR,SAAkBxa,GACd,IAAIjB,EAAOkD,KAAKwY,GAAMza,GAEtB,GAAIjB,aAAgB,EAAAga,MAAQha,EAAK2b,SAAU,OAAO3b,EAAK2b,SAGvD,IAAIC,EAAK5b,EAAK+Z,gBACV,GACA,SAAC8B,GACG,SAAIA,aAAc,EAAA7B,MACV6B,EAAGF,SAKf,IAGJ,OAAIC,EAAGnG,OAAS,EAAUmG,EAAG,GAAGD,SAAsB,IAE1D,EAEQ,YAAAD,GAAR,SAAc5I,GACV,OAAiB,MAAbA,EAAGC,OAAuBD,EACvB5P,KAAKwY,GAAM5I,EAAGC,OACzB,EAEQ,YAAA+I,GAAR,SAAiChJ,GAC7B,IAAI8I,EAAqB,IAAIzV,MAO7B,OANI2M,aAAc,EAAAiJ,cAAcH,EAAGvB,KAAKvH,GACxCA,EAAGJ,aAAY,SAACmJ,GAEZ,OADIA,aAAc,EAAAE,cAAcH,EAAGvB,KAAKwB,IACjC,CACX,IACA,GACOD,CACX,EAEO,YAAA7U,UAAP,SAAiB1E,EAAcI,QAAA,IAAAA,IAAAA,GAAA,GAE3B,IAAIuZ,EAAW9Y,KAAKwY,GAAMrZ,GAC1B,OAAI2Z,aAAoB,EAAAhC,MACpB9W,KAAKR,EAAUsZ,EAKnB9Y,KAAK4U,GAAc5U,KAAK4Y,GAAyBE,GACjD9Y,KAAKP,EAAYO,KAAKuY,GAAUpZ,GAChCa,KAAKsD,GAAQtD,KAAKkP,GAAY/P,EAAQa,KAAK4D,GAAOmV,iBAAiB,GAEnE/Y,KAAKG,EAAW4P,QAGX/P,KAAKsD,IAA2B,MAAlBtD,KAAKP,GAAmBO,KAAKiE,GAAiBjE,KAAKP,GAEtEO,KAAKmO,GAAQhP,GACba,KAAK0J,eAAenK,IAEb,IAfHuE,QAAQC,MAAM,4EACP,EAef,EAIO,YAAAiV,cAAP,SAAqBC,GACjB,IAAKA,EAID,OAHuB,MAAnBjZ,KAAKuD,IAAoBvD,KAAKuD,GAAW2V,UAC7ClZ,KAAKuD,GAAa,UACG,MAAjBvD,KAAKmC,KAAoBnC,KAAKmC,GAAS+W,UAAWlZ,KAAKmC,GAAW,OAG1E,GAAwB,OAApBnC,KAAKuD,GAAT,CAOA,IANA,IAAIgG,EAA0B,IAAI,EAAAkG,cAAc,YAAazP,KAAK4D,IAE9DvG,EAAI2C,KAAKR,EAAQ+J,UAAUyE,EAC3BhB,EAAIhN,KAAKR,EAAQ+J,UAAUmE,EAEzB8H,EAAS,GACP2D,GAASrZ,KAAKC,GAAG,EAAGoZ,EAAQrZ,KAAKC,GAAG,EAAGoZ,GAASrZ,KAAKC,GAAG,GAC5DyV,EAAO2B,KAAK,IAAIiC,QAAQ7Y,QAAQ,EAAGyM,EAAIlN,KAAKuZ,IAAIF,GAAQ9b,EAAIyC,KAAKwZ,IAAIH,KAGzE,IAAMI,EAAwB,GAC9BA,EAAQ,GAAK,EAAA7D,YAAA,YAAwB,IAAK,CAACF,OAAOA,GAASxV,KAAK4D,IAChE2V,EAAQ,GAAGC,MAAQ,EAAAC,OAAA,MACnBF,EAAQ,GAAG1J,OAAStG,EACpBgQ,EAAQ,GAAGvC,YAAa,EAGxB,IAFA,IACM0C,EAAS,EAAI5Z,KAAKC,GADV,GAENzC,EAAI,EAAGA,EAFD,GAEYA,IAClBic,EAAQjc,GAAKic,EAAQ,GAAG1Q,MAAM,KAAOvL,GACrCic,EAAQjc,GAAGuS,OAAStG,EACpBgQ,EAAQjc,GAAGqQ,SAASD,EAAIpQ,EAAIoc,EAC5BH,EAAQjc,GAAG0Z,YAAa,EAEhCzN,EAAUsG,OAAS7P,KAAKR,EACxB+J,EAAUoH,SAAW3Q,KAAKR,EAAQgK,gBAClCxJ,KAAKuD,GAAYgG,CA1BmB,CA2BxC,EAEO,YAAAoQ,UAAP,WACI,OAAO3Z,KAAKR,CAChB,EAIO,YAAAoa,kBAAP,SAAyBnB,GACrBzY,KAAKP,EAAYgZ,EAGK,MAAlBzY,KAAKP,GAAqBO,KAAK6Z,GAAgBpB,GAAWzY,KAAKsD,IAAQ,EAAWtD,KAAKsD,IAAQ,EAE9FtD,KAAKsD,IAA2B,MAAlBtD,KAAKP,GAAmBO,KAAKiE,GAAiBjE,KAAKP,EAC1E,EAIQ,YAAAoa,GAAR,SAAwBpB,GAAxB,WACI,OAAOA,EAASqB,WAAWC,MAAK,SAAAC,GAAM,SAAKpW,GAAOmV,gBAAgBgB,MAAK,SAAAhT,GAAM,OAAAA,EAAGkT,SAASF,MAAK,SAAApP,GAAM,OAAAA,EAAGC,WAAaoP,CAAhB,GAAvB,GAAvC,GAC1C,EAEO,YAAAE,YAAP,WACI,OAAOla,KAAKP,CAChB,EA6EJ,EAv/DA,GA2/DA,aAcI,aAZO,KAAAmU,IAAiB,EACjB,KAAAoC,IAAqB,EACrB,KAAAF,IAAsB,EACtB,KAAAC,IAAqB,EACrB,KAAAG,IAAsB,EACtB,KAAAD,IAAqB,EACrB,KAAAhF,IAAiB,EAGjB,KAAAyC,IAAqB,EAIxB1T,KAAK+P,OACT,CAYJ,OAVI,YAAAA,MAAA,WACI/P,KAAK4T,IAAQ,EACb5T,KAAKgW,IAAY,EACjBhW,KAAK8V,IAAa,EAClB9V,KAAK+V,IAAY,EACjB/V,KAAKkW,IAAa,EAClBlW,KAAKiW,IAAY,EACjBjW,KAAKiR,IAAQ,EACbjR,KAAK0T,IAAY,CACrB,EACJ,EA5BA,GA8BA,aAoBI,WAAmBjM,EAAarC,EAAWhH,QAAX,IAAAgH,IAAAA,EAAA,GAPzB,KAAAuC,KAAe,GAEf,KAAAC,MAAgB,EAChB,KAAAC,KAAe,EAEf,KAAAf,OAAiB,EAGpB9G,KAAKyH,GAAKA,EACVzH,KAAKoF,MAAQA,EACbpF,KAAKma,GAAK/U,EACVpF,KAAK5B,IAAMA,EACX4B,KAAKoa,GAAKhc,CACd,CAYJ,OAVW,YAAA2R,MAAP,WACI/P,KAAK2H,KAAO,GACZ3H,KAAKoF,MAAQpF,KAAKma,GAClBna,KAAK5B,IAAM4B,KAAKoa,GAChBpa,KAAK4H,MAAO,EACZ5H,KAAK6H,KAAO,EACZ7H,KAAK8H,MAAQ,KACb9H,KAAK8G,OAAQ,CACjB,EAEJ,EAtCA,GAwCauT,EAAU,CACnBC,KAAM,OACNC,SAAU,WACVC,aAAc,eACdC,KAAM,OACNC,SAAU,WACVC,IAAK,MACLC,QAAS,UACTC,KAAM,OACNC,SAAU,WACVC,aAAc,eACdC,UAAW,YACXC,cAAe,gBACfC,WAAY,aACZC,eAAgB,iBAChBC,YAAa,cACbC,gBAAiB,kBACjBC,UAAW,YACXC,OAAQ,WAAM,OAAAjd,OAAOkd,OAAOnB,GAASoB,QAAO,SAAAxO,GAAK,MAAa,iBAANA,CAAP,GAAnC,GAIlB,0BACW,KAAA9H,KAAO,IAAIqC,EAAW6S,EAAQC,KAAM,EAAG,KACvC,KAAA9U,SAAW,IAAIgC,EAAW6S,EAAQE,SAAU,IAAK,KACjD,KAAA7U,aAAe,IAAI8B,EAAW6S,EAAQG,aAAc,EAAG,MACvD,KAAAhP,KAAO,IAAIhE,EAAW6S,EAAQI,KAAM,EAAG,MACvC,KAAA7U,SAAW,IAAI4B,EAAW6S,EAAQK,SAAU,EAAG,KAC/C,KAAApV,IAAM,IAAIkC,EAAW6S,EAAQM,IAAK,EAAG,MACrC,KAAA9U,QAAU,IAAI2B,EAAW6S,EAAQO,QAAS,EAAG,MAC7C,KAAAvO,KAAO,IAAI7E,EAAW6S,EAAQQ,KAAM,EAAG,MACvC,KAAAvU,SAAW,IAAIkB,EAAW6S,EAAQS,SAAUhb,KAAKC,GAAK,EAAG,KACzD,KAAA0G,aAAe,IAAIe,EAAW6S,EAAQU,aAAcjb,KAAKC,GAAK,EAAG,MACjE,KAAAwG,UAAY,IAAIiB,EAAW6S,EAAQW,UAAWlb,KAAKC,GAAK,EAAG,KAC3D,KAAA2G,cAAgB,IAAIc,EAAW6S,EAAQY,cAAenb,KAAKC,GAAK,EAAG,MACnE,KAAAgG,WAAa,IAAIyB,EAAW6S,EAAQa,WAAY,IAAK,KACrD,KAAAjV,eAAiB,IAAIuB,EAAW6S,EAAQc,eAAgB,EAAG,MAC3D,KAAAhV,YAAc,IAAIqB,EAAW6S,EAAQe,YAAa,IAAK,KACvD,KAAAtP,gBAAkB,IAAItE,EAAW6S,EAAQgB,gBAAiB,EAAG,MAC7D,KAAA/P,UAAY,IAAI9D,EAAW6S,EAAQiB,UAAW,EAAG,KAqB5D,QAnBW,YAAAvL,MAAP,WAEI,IADA,IACgB,MADKzR,OAAO+I,KAAKrH,MACjB,eAAM,CAAjB,IACGwK,EAAMxK,KADF,MAEFwK,aAAehD,GACrBgD,EAAIuF,O,CAEZ,EAEO,YAAA2L,YAAP,WAGI,IAFA,IAAIC,EAAgB,IAAI1Y,MAER,MADK3E,OAAO+I,KAAKrH,MACjB,eAAM,CAAjB,IACGwK,EAAMxK,KADF,MAEFwK,aAAehD,GACrBmU,EAAIxE,KAAK3M,EAAI/C,G,CAEjB,OAAOkU,CACX,EACJ,EAtCA,GAwCA,aAMW,KAAA7S,eAAyB,EAEzB,KAAAE,cAAwB,EACxB,KAAAJ,aAAwB,EAAArI,QAAA,OACxB,KAAA4I,eAAyB,EACzB,KAAAX,SAAmB,EAEnB,KAAAE,YAAsB,EACtB,KAAAQ,UAAoB,CAK/B,C","sources":["webpack://babylonjs-charactercontroller/webpack/universalModuleDefinition","webpack://babylonjs-charactercontroller/external umd {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack://babylonjs-charactercontroller/webpack/bootstrap","webpack://babylonjs-charactercontroller/webpack/runtime/compat get default export","webpack://babylonjs-charactercontroller/webpack/runtime/define property getters","webpack://babylonjs-charactercontroller/webpack/runtime/hasOwnProperty shorthand","webpack://babylonjs-charactercontroller/webpack/runtime/make namespace object","webpack://babylonjs-charactercontroller/./src/CharacterController.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, (__WEBPACK_EXTERNAL_MODULE__247__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__247__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\r\n    Skeleton,\r\n    ArcRotateCamera,\r\n    Vector3,\r\n    Mesh,\r\n    Node,\r\n    Scene,\r\n    Ray,\r\n    PickingInfo,\r\n    AnimationGroup,\r\n    TransformNode,\r\n    TargetedAnimation,\r\n    Matrix,\r\n    DeepImmutable,\r\n    AbstractMesh,\r\n    PlaySoundAction,\r\n    InstancedMesh,\r\n    Sound,\r\n    AnimationRange,\r\n    Animatable,\r\n    AnimationEvent,\r\n    int,\r\n    LinesMesh,\r\n    MeshBuilder,\r\n    Color3,\r\n    Quaternion\r\n} from \"babylonjs\";\r\n\r\n\r\nexport class CharacterController {\r\n\r\n    private _avatar: Mesh = null;\r\n    private _skeleton: Skeleton = null;\r\n    private _camera: ArcRotateCamera;\r\n    private _scene: Scene;\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n\r\n    private _gravity: number = 9.8;\r\n    //slopeLimit in degrees\r\n    private _minSlopeLimit: number = 30;\r\n    private _maxSlopeLimit: number = 45;\r\n    //slopeLimit in radians\r\n    private _sl1: number = Math.PI * this._minSlopeLimit / 180;\r\n    private _sl2: number = Math.PI * this._maxSlopeLimit / 180;\r\n\r\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\r\n    private _stepOffset: number = 0.25;\r\n\r\n    \r\n    private _actionMap: ActionMap = new ActionMap();\r\n\r\n    private _cameraElastic: boolean = true;\r\n    private _cameraTarget: Vector3 = Vector3.Zero();\r\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\r\n    private _noFirstPerson: boolean = false;\r\n\r\n    private _down: Vector3 = Vector3.DownReadOnly;\r\n    private _animBlend:number;\r\n\r\n\r\n    public setSlopeLimit(minSlopeLimit: number, maxSlopeLimit: number) {\r\n        this._minSlopeLimit = minSlopeLimit;\r\n        this._maxSlopeLimit = maxSlopeLimit;\r\n\r\n        this._sl1 = Math.PI * this._minSlopeLimit / 180;\r\n        this._sl2 = Math.PI * this._maxSlopeLimit / 180;\r\n    }\r\n\r\n    /**\r\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\r\n     * Default value is 0.25 m\r\n     */\r\n    public setStepOffset(stepOffset: number) {\r\n        this._stepOffset = stepOffset;\r\n    }\r\n\r\n    public setWalkSpeed(n: number) {\r\n        this._actionMap.walk.speed = n;\r\n    }\r\n    public setRunSpeed(n: number) {\r\n        this._actionMap.run.speed = n;\r\n    }\r\n    public setBackSpeed(n: number) {\r\n        this._actionMap.walkBack.speed = n;\r\n    }\r\n    public setBackFastSpeed(n: number) {\r\n        this._actionMap.walkBackFast.speed = n;\r\n    }\r\n    public setJumpSpeed(n: number) {\r\n        this._actionMap.idleJump.speed = n;\r\n        this._actionMap.runJump.speed = n;\r\n    }\r\n    public setLeftSpeed(n: number) {\r\n        this._actionMap.strafeLeft.speed = n;\r\n    }\r\n    public setLeftFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast.speed = n;\r\n    }\r\n    public setRightSpeed(n: number) {\r\n        this._actionMap.strafeRight.speed = n;\r\n    }\r\n    public setRightFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast.speed = n;\r\n    }\r\n    // get turnSpeed in degrees per second.\r\n    // store in radians per second\r\n    public setTurnSpeed(n: number) {\r\n        this._actionMap.turnLeft.speed = n * Math.PI / 180;\r\n        this._actionMap.turnRight.speed = n * Math.PI / 180;\r\n    }\r\n    public setTurnFastSpeed(n: number) {\r\n        this._actionMap.turnLeftFast.speed = n * Math.PI / 180;\r\n        this._actionMap.turnRightFast.speed = n * Math.PI / 180;\r\n    }\r\n    public setGravity(n: number) {\r\n        this._gravity = n;\r\n    }\r\n\r\n    /**\r\n     * Use this to provide animationGroups to the character controller.\r\n     * Provide the AnimationGroups using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animationGroup.\r\n     * Example:\r\n     * let myWalkAnimationGroup:AnimationGroup = ...;\r\n     * let agMap:{} = {\r\n     *  \"walk\":myWalkAnimationGroup,\r\n     *  \"run\" : {\"ag\":myRunAnimationGroup,\"rate\":1},\r\n     *  \"idle\" : {\"ag\":myIdleAnimationGroup,\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     *   ....\r\n     * }\r\n     * \r\n     * @param agMap a map of character controller animation name to animationGroup\r\n     */\r\n    public setAnimationGroups(agMap: {}) {\r\n        if (this._prevActData != null && this._prevActData.exist) this._prevActData.ag.stop();\r\n        this._isAG = true;\r\n        this.setActionMap(<ActionMap>agMap);\r\n    }\r\n\r\n    /**\r\n     * Use this to provide AnimationRanges to the character controller.\r\n     * Provide the AnimationRanges using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animation range name or an object with animation range data.\r\n     * example:\r\n     * let arMap = {\r\n     *  \"walk\":\"myWalk\",\r\n     *  \"run\" : {\"name\":\"myRun\",\"rate\":1},\r\n     *  \"idle\" : {\"name\":\"myIdle\",\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     * }\r\n     * \r\n     * @param arMap a map of character controller animation name to animationRange data\r\n     */\r\n\r\n    public setAnimationRanges(arMap: {}) {\r\n        this._isAG = false;\r\n        this.setActionMap(<ActionMap>arMap);\r\n    }\r\n\r\n    /**\r\n     * updates action data in the cc actionMap\r\n     * with action data from the provided/input actionMap \r\n     * \r\n     * \r\n     * return \"ar\" or \"ag\" depending on if the data provided\r\n     * was animation range or animation group data respt.\r\n     * \r\n     * TODO should validate provided data.\r\n     * In other words if animation range provided make sure\r\n     * the range exist in the skeleton\r\n     * or if animation group provided make sure the animation group\r\n     * can be played on this avataor\r\n     * \r\n     * @param inActMap \r\n     * @returns \r\n     */\r\n    public setActionMap(inActMap: ActionMap): string {\r\n        let agMap: boolean = false;\r\n        let inActData: ActionData;\r\n\r\n\r\n        let ccActionNames: string[] = Object.keys(this._actionMap);\r\n        for (let ccActionName of ccActionNames) {\r\n            let ccActData = this._actionMap[ccActionName];\r\n            //some keys could map to functions (like reset())\r\n            if (!(ccActData instanceof ActionData)) continue;\r\n            ccActData.exist = false;\r\n\r\n            inActData = inActMap[ccActData.id];\r\n            //in previous version of cc the key value was AnimationGroup rather than ActionData\r\n            //lets accomodate that for backward compatibility\r\n            if (inActData != null) {\r\n                if (inActData instanceof AnimationGroup) {\r\n                    ccActData.ag = inActData;\r\n                    ccActData.name = ccActData.ag.name;\r\n                    ccActData.exist = true;\r\n                    agMap = true;\r\n                    this._hasAnims = true;\r\n                } else if (inActData.exist) {\r\n                    this._hasAnims = true;\r\n                    ccActData.exist = true;\r\n                    if (inActData instanceof Object) {\r\n                        if (inActData.ag) {\r\n                            ccActData.ag = inActData.ag;\r\n                            agMap = true;\r\n                        }\r\n                        if (inActData.name) {\r\n                            ccActData.name = inActData.name;\r\n                        }\r\n                        if (inActData.loop != null) ccActData.loop = inActData.loop;\r\n                        if (inActData.rate) ccActData.rate = inActData.rate;\r\n                        if (inActData.speed) ccActData.speed = inActData.speed;\r\n                        // if (actDataI.key) actDataO.key = actDataI.key;\r\n                        if (inActData.sound) ccActData.sound = inActData.sound;\r\n                    } else {\r\n                        ccActData.name = inActData;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n        //force to play new anims\r\n        this._prevActData = null;\r\n        if (agMap) return \"ag\"; else return \"ar\";\r\n    }\r\n\r\n    public getActionMap(): ActionMap {\r\n        let map: ActionMap = new ActionMap();\r\n\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let actDataI = this._actionMap[key];\r\n\r\n            if (!(actDataI instanceof ActionData)) continue;\r\n            if (!actDataI.exist) continue;\r\n\r\n            let actDataO: ActionData = map[actDataI.id];\r\n            actDataO.ag = actDataI.ag;\r\n            actDataO.name = actDataI.name;\r\n            actDataO.loop = actDataI.loop;\r\n            actDataO.rate = actDataI.rate;\r\n            actDataO.speed = actDataI.speed;\r\n            actDataO.key = actDataI.key;\r\n            actDataO.sound = actDataI.sound;\r\n            actDataO.exist = actDataI.exist;\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    public getSettings(): CCSettings {\r\n        let ccs: CCSettings = new CCSettings();\r\n        ccs.faceForward = this.isFaceForward();\r\n        ccs.topDown = this.getMode() == 1 ? true : false;\r\n        ccs.turningOff = this.isTurningOff();\r\n        ccs.cameraTarget = this._cameraTarget.clone();\r\n        ccs.cameraElastic = this._cameraElastic;\r\n        ccs.elasticSteps = this._elasticSteps;\r\n        ccs.makeInvisble = this._makeInvisible;\r\n        ccs.gravity = this._gravity;\r\n        ccs.keyboard = this._ekb;\r\n        ccs.maxSlopeLimit = this._maxSlopeLimit;\r\n        ccs.minSlopeLimit = this._minSlopeLimit;\r\n        ccs.noFirstPerson = this._noFirstPerson;\r\n        ccs.stepOffset = this._stepOffset;\r\n        ccs.sound = this._stepSound;\r\n        ccs.animBlend = this._animBlend;\r\n        ccs.ellipsoid = this._avatar.ellipsoid;\r\n        ccs.ellipsoidOffset = this._avatar.ellipsoidOffset;\r\n\r\n        return ccs;\r\n    }\r\n\r\n    public setSettings(ccs: CCSettings) {\r\n        this.setFaceForward(ccs.faceForward);\r\n        this.setMode(ccs.topDown ? 1 : 0);\r\n        this.setTurningOff(ccs.turningOff);\r\n        this.setCameraTarget(ccs.cameraTarget);\r\n        this.setCameraElasticity(ccs.cameraElastic);\r\n        this.setElasticiSteps(ccs.elasticSteps);\r\n        this.makeObstructionInvisible(ccs.makeInvisble);\r\n        this.setGravity(ccs.gravity);\r\n        this.enableKeyBoard(ccs.keyboard);\r\n        this.setSlopeLimit(ccs.minSlopeLimit, ccs.maxSlopeLimit);\r\n        this.setNoFirstPerson(ccs.noFirstPerson);\r\n        this.setStepOffset(ccs.stepOffset);\r\n        this.setSound(ccs.sound);\r\n        this.enableBlending(ccs.animBlend);\r\n        this._avatar.ellipsoid=ccs.ellipsoid;\r\n        this._avatar.ellipsoidOffset=ccs.ellipsoidOffset;\r\n\r\n    }\r\n\r\n    private _setAnim(anim: ActionData, animName?: string | AnimationGroup, rate?: number, loop?: boolean) {\r\n\r\n        //animation range need skeleton\r\n        if (!this._isAG && this._skeleton == null) return;\r\n\r\n        if (animName != null) {\r\n            if (this._isAG) {\r\n                if (!(animName instanceof AnimationGroup)) return;\r\n                anim.ag = <AnimationGroup>animName;\r\n                anim.exist = true;\r\n            } else {\r\n                if (this._skeleton.getAnimationRange(anim.name) != null) {\r\n                    anim.name = <string>animName;\r\n                    anim.exist = true;\r\n                } else {\r\n                    anim.exist = false;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (loop != null) anim.loop = loop;\r\n        if (rate != null) anim.rate = rate;\r\n    }\r\n\r\n    public enableBlending(n: number) {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let act = this._actionMap[key];\r\n                if (!(act instanceof ActionData)) continue;\r\n                if (act.exist) {\r\n                    let ar: AnimationGroup = act.ag;\r\n                    this._animBlend = n;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = true;\r\n                        ta.animation.blendingSpeed = n;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (this._skeleton !== null){\r\n                this._skeleton.enableBlending(n);\r\n                this._animBlend = n;\r\n            }\r\n        }\r\n    }\r\n\r\n    public disableBlending() {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let anim = this._actionMap[key];\r\n                if (!(anim instanceof ActionData)) continue;\r\n                if (anim.exist) {\r\n                    let ar: AnimationGroup = anim.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //setters for animations\r\n    public setWalkAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walk, rangeName, rate, loop);\r\n    }\r\n    public setRunAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.run, rangeName, rate, loop);\r\n    }\r\n    public setWalkBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBack, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack);\r\n    }\r\n    public setWalkBackFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBackFast, rangeName, rate, loop);\r\n    }\r\n    public setSlideBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.slideBack, rangeName, rate, loop);\r\n    }\r\n    public setIdleAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idle, rangeName, rate, loop);\r\n    }\r\n    public setTurnRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n    }\r\n    public setTurnRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRightFast, rangeName, rate, loop);\r\n    }\r\n    public setTurnLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n    }\r\n    public setTurnLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n    }\r\n    public setStrafeRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRightFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n    public setStrafeLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setIdleJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idleJump, rangeName, rate, loop);\r\n    }\r\n    public setRunJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.runJump, rangeName, rate, loop);\r\n    }\r\n    public setFallAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.fall, rangeName, rate, loop);\r\n    }\r\n\r\n\r\n    _stepSound: Sound;\r\n    // setters for sound\r\n    public setSound(sound: Sound) {\r\n        if (sound == null) return;\r\n        this._stepSound = sound;\r\n        let ccActionNames: string[] = Object.keys(this._actionMap);\r\n        sound.loop = false;\r\n        for (let ccActionName of ccActionNames) {\r\n            let ccActData = this._actionMap[ccActionName];\r\n            //some keys could map to functions (like reset())\r\n            if (!(ccActData instanceof ActionData)) continue;\r\n            ccActData.sound = sound;\r\n            ccActData.sound.attachToMesh(this._avatar);\r\n        }\r\n        this._actionMap.idle.sound = null;\r\n        this._actionMap.fall.sound = null;\r\n        this._actionMap.slideBack.sound = null;\r\n    }\r\n\r\n\r\n    // setters for keys\r\n    public setWalkKey(key: string) {\r\n        this._actionMap.walk.key = key.toLowerCase();\r\n    }\r\n    public setWalkBackKey(key: string) {\r\n        this._actionMap.walkBack.key = key.toLowerCase();\r\n    }\r\n    public setTurnLeftKey(key: string) {\r\n        this._actionMap.turnLeft.key = key.toLowerCase();\r\n    }\r\n    public setTurnRightKey(key: string) {\r\n        this._actionMap.turnRight.key = key.toLowerCase();\r\n    }\r\n    public setStrafeLeftKey(key: string) {\r\n        this._actionMap.strafeLeft.key = key.toLowerCase();\r\n    }\r\n    public setStrafeRightKey(key: string) {\r\n        this._actionMap.strafeRight.key = key.toLowerCase();\r\n    }\r\n    public setJumpKey(key: string) {\r\n        this._actionMap.idleJump.key = key.toLowerCase();\r\n    }\r\n\r\n    public setCameraElasticity(b: boolean) {\r\n        this._cameraElastic = b;\r\n    }\r\n\r\n    public setElasticiSteps(n: number) {\r\n        this._elasticSteps = n;\r\n    }\r\n\r\n    public makeObstructionInvisible(b: boolean) {\r\n        this._makeInvisible = b;\r\n    }\r\n    public setCameraTarget(v: Vector3) {\r\n        this._cameraTarget.copyFrom(v);\r\n    }\r\n\r\n\r\n    /**\r\n     * user should call this whenever the user changes the camera checkCollision \r\n     * property\r\n     * \r\n     */\r\n    public cameraCollisionChanged() {\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n    }\r\n    public setNoFirstPerson(b: boolean) {\r\n        this._noFirstPerson = b;\r\n    }\r\n\r\n    /**\r\n     * if av has the required anim (walk, run etc) then \r\n     * mark that anim as existing\r\n     * \r\n     * @param skel \r\n     */\r\n\r\n    private _checkAnimRanges(skel: Skeleton) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof ActionData)) continue;\r\n            if (skel != null) {\r\n                if (skel.getAnimationRange(anim.id) != null) {\r\n                    anim.name = anim.id;\r\n                    anim.exist = true;\r\n                    this._hasAnims = true;\r\n                }\r\n            } else {\r\n                anim.exist = false;\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n    }\r\n\r\n    /**\r\n     * if fast anims do not exist then use their slow counterpart as them but double the rate at which they play\r\n     */\r\n    private _checkFastAnims() {\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack)\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n\r\n    private _copySlowAnims(f: ActionData, s: ActionData) {\r\n        if (f.exist) return;\r\n        if (!s.exist) return;\r\n        f.exist = true;\r\n        f.ag = s.ag;\r\n        f.name = s.name;\r\n        f.rate = s.rate * 2;\r\n    }\r\n\r\n    /**\r\n     * Use this to make the  character controller suitable for a isometeric/top down games or  fps/third person game.\r\n     * 1 In isometric/top down games the camera direction has no bearing on avatar movement.\r\n     * 0 In fps/third person game rotating the camera around the avatar , rotates the avatar too.\r\n     * \r\n     * cannot switch mode to 0 if no camera avaiable.\r\n     */\r\n    private _mode = 0;\r\n    private _saveMode = 0;\r\n    public setMode(n: number) {\r\n        //cannot switch mode to 0 if no camera avaiable.\r\n        if (this._hasCam) {\r\n            this._mode = n;\r\n            this._saveMode = n;\r\n        } else {\r\n            this._mode = 1;\r\n            this._saveMode = 1;\r\n        }\r\n    }\r\n    public getMode() {\r\n        return this._mode;\r\n    }\r\n    /**\r\n     * Use this to set  turning off.\r\n     * When turining is off \r\n     * a) turn left or turn right keys result in avatar facing and moving left or right with respect to camera.\r\n     * b) walkback/runback key results in avatar facing back and walking/running towards camera.\r\n     * \r\n     * This setting has no effect when mode is 1.\r\n     * \r\n     * @param b \r\n     */\r\n    public setTurningOff(b: boolean) {\r\n        this._noRot = b;\r\n    }\r\n    public isTurningOff() {\r\n        return this._noRot;\r\n    }\r\n\r\n    /**\r\n        * checks if a have left hand , right hand issue.\r\n        * In other words if a mesh is a LHS mesh in RHS system or \r\n        * a RHS mesh in LHS system\r\n        * The X axis will be reversed in such cases.\r\n        * thus Cross product of X and Y should be inverse of Z.\r\n        * BABYLONJS GLB models are RHS and exhibit this behavior\r\n        * \r\n        */\r\n    /**\r\n     * Helper methods to get/set Y rotation that work with both Euler and Quaternion\r\n     */\r\n    private _getAvatarRotationY(): number {\r\n        if (this._avatar.rotationQuaternion) {\r\n            return this._avatar.rotationQuaternion.toEulerAngles().y;\r\n        }\r\n        return this._avatar.rotation.y;\r\n    }\r\n\r\n    private _setAvatarRotationY(angle: number): void {\r\n        if (this._avatar.rotationQuaternion) {\r\n            const euler = this._avatar.rotationQuaternion.toEulerAngles();\r\n            euler.y = angle;\r\n            this._avatar.rotationQuaternion = Quaternion.RotationYawPitchRoll(euler.y, euler.x, euler.z);\r\n        } else {\r\n            this._avatar.rotation.y = angle;\r\n        }\r\n    }\r\n\r\n    private _addToAvatarRotationY(angle: number): void {\r\n        if (this._avatar.rotationQuaternion) {\r\n            const euler = this._avatar.rotationQuaternion.toEulerAngles();\r\n            euler.y += angle;\r\n            this._avatar.rotationQuaternion = Quaternion.RotationYawPitchRoll(euler.y, euler.x, euler.z);\r\n        } else {\r\n            this._avatar.rotation.y += angle;\r\n        }\r\n    }\r\n\r\n    private _isLHS_RHS = false;\r\n    private _signLHS_RHS = -1;\r\n    private _setRHS(mesh: TransformNode) {\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        const _localX = Vector3.FromArray(meshMatrix.m, 0);\r\n        const _localY = Vector3.FromArray(meshMatrix.m, 4);\r\n        const _localZ = Vector3.FromArray(meshMatrix.m, 8);\r\n        const actualZ = Vector3.Cross(_localX, _localY);\r\n        //same direction or opposite direction of Z\r\n        if (Vector3.Dot(actualZ, _localZ) < 0) {\r\n            this._isLHS_RHS = true;\r\n            this._signLHS_RHS = 1;\r\n        }\r\n        else {\r\n            this._isLHS_RHS = false;\r\n            this._signLHS_RHS = -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use setFaceForward(true|false) to indicate that the avatar's face  points forward (true) or backward (false).\r\n     * The avatar's face  points forward if its face is looking in positive local Z axis direction\r\n     */\r\n    private _ffSign: number;\r\n    private _rhsSign: number;\r\n    private _ff: boolean;\r\n    //in mode 0, av2cam is used to align avatar with camera , with camera always facing avatar's back\r\n    //note:camera alpha is measured anti-clockwise , avatar rotation is measured clockwise \r\n    private _av2cam;\r\n    public setFaceForward(b: boolean) {\r\n        this._ff = b;\r\n\r\n        this._rhsSign = this._scene.useRightHandedSystem ? -1 : 1;\r\n\r\n        \r\n\r\n        if (this._isLHS_RHS) {\r\n            this._av2cam = b ? Math.PI / 2 : 3 * Math.PI / 2;\r\n            this._ffSign = b ? 1 : -1;\r\n        } else {\r\n            this._av2cam = b ? 3 * Math.PI / 2 : Math.PI / 2;\r\n            this._ffSign = b ? -1 : 1;\r\n        }\r\n\r\n        if (!this._hasCam) {\r\n            this._av2cam = 0;\r\n            return;\r\n        }\r\n\r\n    }\r\n\r\n    public isFaceForward() {\r\n        return this._ff;\r\n    }\r\n\r\n    private checkAGs(agMap: {}) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof ActionData)) continue;\r\n            if (agMap[anim.name] != null) {\r\n                anim.ag = agMap[anim.name];\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // check if any of the mesh on the node tree is refrenced by any animation group\r\n    private _containsAG(node: Node, ags: AnimationGroup[], fromRoot: boolean) {\r\n        let r: Node;\r\n        let ns: Node[];\r\n\r\n        if (fromRoot) {\r\n            r = this._getRoot(node);\r\n            ns = r.getChildren((n) => { return (n instanceof TransformNode) }, false);\r\n        } else {\r\n            r = node;\r\n            ns = [r];\r\n        }\r\n\r\n        for (let ag of ags) {\r\n            let tas: TargetedAnimation[] = ag.targetedAnimations;\r\n            for (let ta of tas) {\r\n                if (ns.indexOf(ta.target) > -1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //get the root of Node\r\n    private _getRoot(tn: Node): Node {\r\n        if (tn.parent == null) return tn;\r\n        return this._getRoot(tn.parent);\r\n    }\r\n\r\n    private _started: boolean = false;\r\n    public start() {\r\n        if (this._started) return;\r\n        this._started = true;\r\n        this._act.reset();\r\n        this._movFallTime = 0;\r\n        //first time we enter render loop, delta time is zero\r\n        this._idleFallTime = 0.001;\r\n        this._grounded = false;\r\n        this._updateTargetValue();\r\n        if (this._ekb) this._addkeylistener();\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    public stop() {\r\n        if (!this._started) return;\r\n        this._started = false;\r\n        this._scene.unregisterBeforeRender(this._renderer);\r\n        this._removekeylistener();\r\n        this._prevActData = null;\r\n    }\r\n\r\n    /**\r\n     * use pauseAnim to stop the charactere controller from playing\r\n     * any animation on the character\r\n     * use this when you want to play your animation instead\r\n     * see also resumeAnim()\r\n     */\r\n    private _stopAnim: boolean = false;\r\n    public pauseAnim() {\r\n        this._stopAnim = true;\r\n\r\n        if (this._prevActData != null && this._prevActData.exist) {\r\n            //stop current animation\r\n            if (this._isAG) {\r\n                this._prevActData.ag.stop();\r\n            } else {\r\n                //this._scene.stopAnimation(this._skeleton, this._prevActData.name);\r\n                this._scene.stopAnimation(this._skeleton);\r\n                //this._scene.stopAllAnimations();\r\n            }\r\n            //stop current sound\r\n            if (this._prevActData.sound != null) {\r\n                this._prevActData.sound.stop();\r\n            }\r\n            clearInterval(this._sndId);\r\n\r\n            this._scene.unregisterBeforeRender(this._renderer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * use resumeAnim to resume the character controller playing\r\n     * animations on the character.\r\n     * see also pauseAnim()\r\n     */\r\n    public resumeAnim() {\r\n        this._stopAnim = false;\r\n        this._prevActData = null;\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    private _prevActData: ActionData = null;\r\n    private _avStartPos: Vector3 = Vector3.Zero();\r\n    private _prevPickY: number = 0;\r\n    private _grounded: boolean = false;\r\n    //distance by which AV would move down if in freefall\r\n    private _freeFallDist: number = 0;\r\n\r\n    private _inFreeFall: boolean = false;\r\n    private _wasWalking: boolean = false;\r\n    private _wasRunning: boolean = false;\r\n    private _moveVector: Vector3 = Vector3.Zero();\r\n\r\n    //used only in mode 1\r\n    //value 1 or -1 , -1 if avatar is facing camera\r\n    //private _notFacingCamera = 1;\r\n\r\n    private _isAvFacingCamera(): number {\r\n        if (!this._hasCam) return -1;\r\n        if (Vector3.Dot(this._avatar.forward, this._avatar.position.subtract(this._camera.position)) < 0) return 1\r\n        else return -1;\r\n    }\r\n\r\n    private _moveAVandCamera() {\r\n        this._avStartPos.copyFrom(this._avatar.position);\r\n        let actData: ActionData = null;\r\n        const dt: number = this._scene.getEngine().getDeltaTime() / 1000;\r\n\r\n        if (this._act._jump && !this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            actData = this._doJump(dt);\r\n        } else if (this.anyMovement() || this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            actData = this._doMove(dt);\r\n        } else if (!this._inFreeFall) {\r\n            actData = this._doIdle(dt);\r\n        }\r\n\r\n        if (!this._stopAnim && this._hasAnims && actData != null) {\r\n            // console.log(\"anim: \" + actData.name);\r\n            if (this._prevActData !== actData) {\r\n                if (actData.exist) {\r\n\r\n                    //animation frame counts\r\n                    let c: number;\r\n                    let fps: number = 30;\r\n\r\n                    if (this._isAG) {\r\n                        if (this._prevActData != null && this._prevActData.exist) this._prevActData.ag.stop();\r\n                        actData.ag.start(actData.loop, actData.rate);\r\n                        fps = actData.ag.targetedAnimations[0].animation.framePerSecond;\r\n                        c = (actData.ag.to - actData.ag.from);\r\n                    } else {\r\n                        let a: Animatable = this._skeleton.beginAnimation(actData.name, actData.loop, actData.rate);\r\n                        fps = a.getAnimations()[0].animation.framePerSecond;\r\n                        c = this._skeleton.getAnimationRange(actData.name).to - this._skeleton.getAnimationRange(actData.name).from;\r\n                    }\r\n\r\n                    //SOUND\r\n                    //TODO do sound as animationevent.\r\n                    if (this._prevActData != null && this._prevActData.sound != null) {\r\n                        this._prevActData.sound.stop();\r\n                    }\r\n                    clearInterval(this._sndId);\r\n                    if (actData.sound != null) {\r\n                        actData.sound.play();\r\n                        //play sound twice during the animation\r\n                        this._sndId = setInterval(() => { actData.sound.play(); }, c * 1000 / (fps * Math.abs(actData.rate) * 2));\r\n                    }\r\n                }\r\n                this._prevActData = actData;\r\n            }\r\n        }\r\n        this._updateTargetValue();\r\n        return;\r\n    }\r\n\r\n    private _soundLoopTime = 700;\r\n    private _sndId = null;\r\n\r\n    //verical position of AV when it is about to start a jump\r\n    private _jumpStartPosY: number = 0;\r\n    //for how long the AV has been in the jump\r\n    private _jumpTime: number = 0;\r\n    private _doJump(dt: number): ActionData {\r\n\r\n        let actData: ActionData = null;\r\n        actData = this._actionMap.runJump;\r\n        if (this._jumpTime === 0) {\r\n            this._jumpStartPosY = this._avatar.position.y;\r\n        }\r\n\r\n        this._jumpTime = this._jumpTime + dt;\r\n\r\n        let forwardDist: number = 0;\r\n        let jumpDist: number = 0;\r\n        let disp: Vector3;\r\n\r\n        // if (this._hasCam && this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        if (this._wasRunning || this._wasWalking) {\r\n            if (this._wasRunning) {\r\n                forwardDist = this._actionMap.run.speed * dt;\r\n            } else if (this._wasWalking) {\r\n                forwardDist = this._actionMap.walk.speed * dt;\r\n            }\r\n            //find out in which horizontal direction the AV was moving when it started the jump\r\n            disp = this._moveVector.clone();\r\n            disp.y = 0;\r\n            disp = disp.normalize();\r\n            disp.scaleToRef(forwardDist, disp);\r\n            jumpDist = this._calcJumpDist(this._actionMap.runJump.speed, dt);\r\n            disp.y = jumpDist;\r\n        } else {\r\n            jumpDist = this._calcJumpDist(this._actionMap.idleJump.speed, dt);\r\n            disp = new Vector3(0, jumpDist, 0);\r\n            actData = this._actionMap.idleJump;\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\r\n        }\r\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\r\n        this._avatar.moveWithCollisions(disp);\r\n        if (jumpDist < 0) {\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\r\n            //check if going up a slope or back on flat ground \r\n            if ((this._avatar.position.y > this._avStartPos.y) || ((this._avatar.position.y === this._avStartPos.y) && (disp.length() > 0.001))) {\r\n                this._endJump();\r\n            } else if (this._avatar.position.y < this._jumpStartPosY) {\r\n                //the avatar is below the point from where it started the jump\r\n                //so it is either in free fall or is sliding along a downward slope\r\n                //\r\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n                //else it is on a slope\r\n                const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                    //AV is on slope\r\n                    //Should AV continue to slide or stop?\r\n                    //if slope is less steeper than acceptable then stop else slide\r\n                    let _ng = this._isNearGround(actDisp);\r\n                    if (_ng.slope <= this._sl1) {\r\n                        this._endJump();\r\n                    }\r\n                } else {\r\n                    actData = this._actionMap.fall;\r\n                }\r\n            }\r\n        }\r\n        return actData;\r\n    }\r\n\r\n    private _calcJumpDist(speed: number, dt: number): number {\r\n        //up velocity at the begining of the last frame (v=u+at)\r\n        let js: number = speed - this._gravity * this._jumpTime;\r\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\r\n        let jumpDist: number = js * dt - 0.5 * this._gravity * dt * dt;\r\n        return jumpDist;\r\n    }\r\n\r\n    /**\r\n     * does cleanup at the end of a jump\r\n     */\r\n    private _endJump() {\r\n        this._act._jump = false;\r\n        this._jumpTime = 0;\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n    }\r\n\r\n    /**\r\n     * checks if two vectors v1 and v2 are equal within a precision of p\r\n     */\r\n    private _areVectorsEqual(v1: Vector3, v2: Vector3, p: number) {\r\n        return ((Math.abs(v1.x - v2.x) < p) && (Math.abs(v1.y - v2.y) < p) && (Math.abs(v1.z - v2.z) < p));\r\n    }\r\n\r\n    /*\r\n     * returns the slope (in radians) of a vector in the vertical plane\r\n     */\r\n    private _verticalSlope(v: Vector3): number {\r\n        return Math.atan(Math.abs(v.y / Math.sqrt(v.x * v.x + v.z * v.z)));\r\n    }\r\n\r\n    //for how long has the av been falling while moving\r\n    private _movFallTime: number = 0;\r\n    private _sign = 1;\r\n    private _isTurning = false;\r\n    private _noRot = false;\r\n    private _steps = true;\r\n    private _stepHigh:boolean = false;\r\n    private _doMove(dt: number): ActionData {\r\n        // console.log(\"doMove\");\r\n\r\n        //initial down velocity (v=u+at)\r\n        const u: number =  this._gravity * this._movFallTime ;\r\n\r\n        //calculate the distance by which av should move down since last frame\r\n        //s=ut+att/2\r\n        this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n\r\n        this._movFallTime = this._movFallTime + dt;\r\n\r\n        let moving: boolean = false;\r\n        let actdata: ActionData = null;\r\n\r\n        this._moveVector.x=0;\r\n        this._moveVector.y=0;\r\n        this._moveVector.z=0;\r\n\r\n        if (this._inFreeFall) {\r\n            this._moveVector.y = -this._freeFallDist;\r\n            moving = true;\r\n        }\r\n\r\n\r\n        //rotate avatar with respect to camera direction. \r\n        this._rotateAV2C();\r\n\r\n        //rotate the avatar in case player is trying to rotate the avatar. rotate the camera too if camera turning is on\r\n        actdata = this._rotateAVnC(actdata, moving, dt);\r\n\r\n        //now that avatar is rotated properly, construct the vector to move the avatar \r\n        //donot move the avatar if avatar is in freefall\r\n\r\n        if (!this._inFreeFall) {\r\n            this._wasWalking = false;\r\n            this._wasRunning = false;\r\n\r\n            let sign: number;\r\n            let horizDist: number = 0;\r\n            switch (true) {\r\n                case (this._act._stepLeft):\r\n                    // console.log(\"step left\");\r\n                    sign = this._signLHS_RHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeLeft.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeLeftFast.speed * dt;\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._stepRight):\r\n                    // console.log(\"step right\");\r\n                    sign = -this._signLHS_RHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeRight.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeRightFast.speed * dt;\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walk || (this._noRot && this._mode == 0)):\r\n                    // console.log(\"walk\");\r\n                    if (this._act._speedMod) {\r\n                        this._wasRunning = true;\r\n                        horizDist = this._actionMap.run.speed * dt;\r\n                        actdata = this._actionMap.run;\r\n                    } else {\r\n                        this._wasWalking = true;\r\n                        horizDist = this._actionMap.walk.speed * dt;\r\n                        actdata = this._actionMap.walk;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walkback):\r\n                    // console.log(\"walk back\");\r\n                    horizDist = this._actionMap.walkBack.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.walkBackFast.speed * dt;\r\n                        actdata = this._actionMap.walkBackFast;\r\n                    } else {\r\n                        actdata = this._actionMap.walkBack;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, -this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // move the avatar\r\n        if (moving) {\r\n            if (this._moveVector.length() > 0.001) {\r\n                this._avatar.moveWithCollisions(this._moveVector);\r\n\r\n                let actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n\r\n                const _ng = this._isNearGround(actDisp);\r\n\r\n                //walking up a step or a  slope\r\n                if (this._avatar.position.y - this._avStartPos.y > 0.01) {\r\n                //if (this._avatar.position.y > this._avStartPos.y) {\r\n                    //if AV is going up even though slope is 0 then that means AV is trying to climb steps\r\n                    //The elliptical shape of ellipsoid allows this.\r\n                    if (_ng.hit && _ng.slope == 0 ) {\r\n                        //if user has specified step offset then prevent AV from going beyond that\r\n                        //otherwise allow whatever the ellisoid allows\r\n                        if (this._stepOffset > 0) {\r\n\r\n                            //The pick ray being in front, will pick a step and \r\n                            //thus can be used to calc the step height\r\n                            let stepHeight = _ng.y - this._avStartPos.y;\r\n\r\n                            //if the step height is more than that allowed\r\n                            if (stepHeight > this._stepOffset) {\r\n                                this._stepHigh = true;\r\n                            }else{\r\n                                this._stepHigh = false;\r\n                            }\r\n\r\n                            //if the total amount by which the AV has moved up exceeds the allowable limit then\r\n                            //move av back to its position at begining of steps\r\n                             if (this._stepHigh) {\r\n                                //move av back to its position at begining of steps\r\n                                this._avatar.position.copyFrom(this._avStartPos);\r\n                            }else{\r\n                                this._avatar.position.y = _ng.y;\r\n                                this._movFallTime = 0;\r\n                            }\r\n                         }\r\n                    } else {\r\n                        //looks like the avatar is going up a slope\r\n                        const _slp = _ng.slope;\r\n\r\n                        //if slope is less than the higher slope limit then continue moving up\r\n                        //if slope is greater than the higher slope limit then stop moving up\r\n                        //\r\n                        //But sometimes even if the the slope is greater than the higher slope limit \r\n                        //we may want avatar to continue moving up the slope.\r\n                        //Remember that the the ray is in front of the avatar (when the avatar is facing the slope).\r\n                        //Thus the slope read, is not the slope of the ground under the avatar but of ground in front of the avatar.\r\n                        //Now the ground in front can suddenly start sloping down more than allowable limit.\r\n                        //In that case the avatar should not stop but continue moving forward.\r\n                        //To identify this use case we need to check if the current pickpoint is below the previous pickpoint.\r\n                        //Normally if we are going up the slope then the current pickpoint\r\n                        //should always be above the previous pickpoint.\r\n                        //If this is not the case then we have identifed this use case of a downward slope ahead.\r\n                        //Note: the slope does not tell us if it is a upward slope or a downward slope\r\n\r\n                        if (_slp >= this._sl2 && _ng.y > this._prevPickY) {\r\n                       // if (_slp >= this._sl2 ) {\r\n                            //move av back to old position\r\n                            this._avatar.position.copyFrom(this._avStartPos);\r\n                            this._endFreeFall();\r\n                            this._prevPickY = 0;\r\n                        } else {\r\n                            //keep moving up the slope\r\n                            this._prevPickY = _ng.y;\r\n                            if (_slp > this._sl1) {\r\n                                //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                                this._inFreeFall = false;\r\n                            } else {\r\n                                //continue walking\r\n                                this._endFreeFall();\r\n                            }\r\n                        }\r\n                    }\r\n                   \r\n                } else if ( this._avatar.position.y < this._avStartPos.y ) {\r\n                    // if (this._avStartPos.y - this._avatar.position.y > 0.01 ) {\r\n                    //av is going down a slope or is in free fall\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n\r\n                    //if the AV falls by an amount equal to the free fall distance calculated then it is in freefall\r\n                    //Now the AV could be going down a slope but still be seen as if it is in a freefall.\r\n                    //This could happen if the AV is going down a steep fall. In such cases the AV move forward, \r\n                    // goes in freefall,hits the slope,goes in freefall again and so on\r\n                    //To make sure this is not the case check the pickray does not hit the ground or if it does then \r\n                    // the pickpoint is atleast 1 unit(?) below the avatar's position\r\n                    //if (this._areVectorsEqual(actDisp, this._moveVector, 0.001) &&  (!_ng.hit || (_ng.hit && this._avatar.position.y - _ng.y > 1))) {\r\n                    if (this._areVectorsEqual(actDisp, this._moveVector, 0.001) &&  !_ng.hit) {\r\n                        //AV is in freefall\r\n                        this._inFreeFall = true;\r\n                        actdata = this._actionMap.fall;\r\n                    }else {\r\n                          //if (_ng.y >= this._avatar.position.y) {\r\n                        //AV is on ground and thus on slope\r\n                        //\r\n                        //Should AV continue to slide or walk?\r\n                        //if slope is less steeper than acceptable then walk else slide\r\n                        //if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                            if (_ng.slope <= this._sl1) {\r\n                               // this._endFreeFall();\r\n                                this._inFreeFall = false;\r\n                            } else {\r\n                                //av is on a steep slope , keep the moveFallTIme non zero to continue deaccelerate it vertically\r\n                                this._inFreeFall = false;\r\n                            }\r\n                    }\r\n                } else {\r\n                    //AV is walking on a flat surface\r\n                    //this._endFreeFall();\r\n                    this._inFreeFall = false;\r\n                }\r\n            }\r\n        }\r\n        return actdata;\r\n    }\r\n\r\n\r\n\r\n    //check if any collidable mesh is just below the avatar's ellipsoid\r\n    private _isNearGround(actDisp: Vector3): { \"name\": string, \"ground\": boolean, \"slope\": number,\"y\":number,\"hit\":boolean } {\r\n\r\n        let upDist = this._avatar.position.y - this._avStartPos.y;\r\n        let up:boolean = true;\r\n        if (Math.abs(upDist) < 0.006) { \r\n            up = true;\r\n        }else{\r\n            up = (upDist > 0.01 ) ? true : false;\r\n        }\r\n        let fwd: boolean;\r\n        actDisp.y = 0;\r\n        if (actDisp.x == 0 && actDisp.z == 0) {\r\n            fwd = true;\r\n        } else {\r\n            let cosTheta = Vector3.Dot(this._avatar.forward, actDisp.normalize());\r\n            fwd = (cosTheta >= 0) ? true : false;\r\n        }\r\n        let fact = (up && fwd) || (!up && !fwd) ? 1 : -1;\r\n\r\n        //SAT DEBUG\r\n        // fact=1;\r\n\r\n        // send the pick ray vertically down starting from a pont which is\r\n        // a) in the middle of the ellipsoid  and\r\n        // b) either front or back of the avatar\r\n        // if AV is moving forward and up (in otherwords facing the slope) then ray in front\r\n        // if AV is moving backward and down (in otherwords facing the slope) then ray in front\r\n        // if AV is moving forward and down (in otherwords facing away from the slope) then ray in back\r\n        // if AV is moving backward and  up (in otherwords facing away from the slope) then ray in back\r\n        // This way the ray is targetting a point on the ground which is slightly above the avatar feet thus \r\n        // ensuring that the ray will always hit the ground.\r\n        // The length of the ray is such that it atleast reaches the bottom of the avator.\r\n\r\n        this._avatar.forward.scaleToRef(this._avatar.ellipsoid.x * fact, this._ray.origin);\r\n        this._ray.origin.addToRef(this._avatar.position, this._ray.origin);\r\n        this._ray.origin.addToRef(this._avatar.ellipsoidOffset, this._ray.origin);\r\n        //this._avatar.position.addToRef(this._avatar.ellipsoidOffset, this._ray.origin);\r\n        //this._ray.origin.y = this._ray.origin.y - this._avatar.ellipsoid.y;\r\n        //from the bottom of ellipsoid go down 1/4 the ellipsoid height to check for any mesh\r\n        //this._ray.length = this._avatar.ellipsoid.y + this._stepOffset;\r\n        this._ray.length = this._avatar.ellipsoid.y *2;\r\n        //direction is towards the bottom\r\n        this._ray.direction = this._down;\r\n\r\n        //draw pick ray\r\n        if (this._ellipsoid !=null) {\r\n            this._drawLines(this._ray.origin, this._ray.origin.add(new Vector3(0, -this._ray.length, 0)));\r\n        }\r\n\r\n        \r\n        //handle case were pick is with a child of avatar, avatar atatchment. etc\r\n        //check if any collidable mesh is there just below the avatar's ellipsoid\r\n        const pi: PickingInfo = this._scene.pickWithRay(this._ray, (mesh) => {\r\n            if (this._avChildren.includes(mesh)) return false;\r\n            if (mesh.checkCollisions) return true;\r\n            return false;\r\n        });\r\n\r\n        if (pi != null && pi.hit) {\r\n            let n: Vector3 = pi.getNormal(true, true);\r\n            let slope: number = Math.PI / 2 - Math.asin(Math.abs(n.y));\r\n            return { \"name\": pi.pickedMesh.name, \"ground\": true, \"slope\": slope, \"y\":pi.pickedPoint.y, \"hit\":true };\r\n        }\r\n        else return { \"name\": \"\", \"ground\": false, \"slope\": 0, \"y\":0, \"hit\":false };\r\n\r\n    }\r\n\r\n\r\n    //check if any collidable mesh is just below the avatar's ellipsoid\r\n    private _isNearGround_old(): { \"name\": string, \"ground\": boolean, \"slope\": number } {\r\n        //start the ray from the bottom of avatar's ellipsod\r\n        //ellipsoid center = avatar position + ellipsoid offset\r\n        //ellipsoid bottom = ellipsoid center - ellipsoid height \r\n        this._avatar.position.addToRef(this._avatar.ellipsoidOffset, this._ray.origin);\r\n        this._ray.origin.y = this._ray.origin.y - this._avatar.ellipsoid.y;\r\n        //from the bottom of ellipsoid go down 1/4 the ellipsoid height to check for any mesh\r\n        this._ray.length = this._avatar.ellipsoid.y / 2;\r\n        //direction is towards the bottom\r\n        this._ray.direction = this._down;\r\n\r\n\r\n\r\n        //TODO \r\n        //handle case were pick is with a child of avatar, avatar atatchment. etc\r\n        //check if any collidable mesh is there just below the avatar's ellipsoid\r\n        const pis: PickingInfo[] = this._scene.multiPickWithRay(this._ray, (mesh) => {\r\n            if (mesh == this._avatar) return false;\r\n            if (mesh.checkCollisions) return true\r\n            else return false;\r\n        });\r\n\r\n        if (pis.length > 0) {\r\n            let pi: PickingInfo = pis[0];\r\n\r\n            let n: Vector3 = pi.getNormal(true, true);\r\n            let slope: number = Math.PI / 2 - Math.asin(Math.abs(n.y));\r\n\r\n            return { \"name\": pi.pickedMesh.name, \"ground\": true, \"slope\": slope };\r\n        }\r\n        else return { \"name\": \"\", \"ground\": false, \"slope\": 0 };\r\n\r\n    }\r\n\r\n\r\n    //for debugging purpose draws the rayline use to detect slope or steps\r\n    _rayLine: LinesMesh = null;\r\n    _lineOptions:any = {};\r\n    private _drawLines(pt1: Vector3, pt2: Vector3) {\r\n        if (this._rayLine == null){\r\n            const myPoints = [pt1, pt2];\r\n            this._lineOptions = {\r\n                points: myPoints,\r\n                updatable: true\r\n            }\r\n            this._rayLine = MeshBuilder.CreateLines(\"lines\", this._lineOptions );\r\n        }else {\r\n            this._lineOptions.points[0]=pt1;\r\n            this._lineOptions.points[1]=pt2;\r\n            this._lineOptions.instance = this._rayLine;\r\n            this._rayLine = MeshBuilder.CreateLines(\"lines\", this._lineOptions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * rotate avatar with respect to camera direction. \r\n     */\r\n    private _rotateAV2C() {\r\n        if (this._hasCam)\r\n            if (this._mode != 1) {\r\n                let ca = (this._hasCam) ? (this._av2cam - this._camera.alpha) : 0;\r\n                if (this._noRot) {\r\n                    switch (true) {\r\n                        case (this._act._walk && this._act._turnRight):\r\n                            this._setAvatarRotationY(ca + this._rhsSign * Math.PI / 4);\r\n                            break;\r\n                        case (this._act._walk && this._act._turnLeft):\r\n                            this._setAvatarRotationY(ca - this._rhsSign * Math.PI / 4);\r\n                            break;\r\n                        case (this._act._walkback && this._act._turnRight):\r\n                            this._setAvatarRotationY(ca + this._rhsSign * 3 * Math.PI / 4);\r\n                            break;\r\n                        case (this._act._walkback && this._act._turnLeft):\r\n                            this._setAvatarRotationY(ca - this._rhsSign * 3 * Math.PI / 4);\r\n                            break;\r\n                        case (this._act._walk):\r\n                            this._setAvatarRotationY(ca);\r\n                            break;\r\n                        case (this._act._walkback):\r\n                            this._setAvatarRotationY(ca + Math.PI);\r\n                            break;\r\n                        case (this._act._turnRight):\r\n                            this._setAvatarRotationY(ca + this._rhsSign * Math.PI / 2);\r\n                            break;\r\n                        case (this._act._turnLeft):\r\n                            this._setAvatarRotationY(ca - this._rhsSign * Math.PI / 2);\r\n                            break;\r\n                    }\r\n                } else {\r\n                    if (this._hasCam)\r\n                        this._setAvatarRotationY(ca);\r\n                }\r\n            }\r\n    }\r\n\r\n    //rotate the avatar in case player is trying to rotate the avatar. rotate the camera too if camera turning is on\r\n    private _rotateAVnC(anim: ActionData, moving: boolean, dt: number): ActionData {\r\n        if (!(this._noRot && this._mode == 0) && (!this._act._stepLeft && !this._act._stepRight) && (this._act._turnLeft || this._act._turnRight)) {\r\n            let turnAngle = this._actionMap.turnLeft.speed * dt;\r\n            if (this._act._speedMod) {\r\n                turnAngle = 2 * turnAngle;\r\n            }\r\n            let a;\r\n            if (this._mode == 1) {\r\n                // while turining, the avatar could start facing away from camera and end up facing camera.\r\n                // we should not switch turning direction during this transition\r\n                if (!this._isTurning) {\r\n                    // if (this._act.name != this._act.prevName) {\r\n                    // this._act.prevName = this._act.name;\r\n                    this._sign = -this._ffSign * this._isAvFacingCamera();\r\n                    if (this._isLHS_RHS) this._sign = - this._sign;\r\n                    this._isTurning = true;\r\n                }\r\n                a = this._sign;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walk) { }\r\n                    else if (this._act._walkback) a = -this._sign;\r\n                    else {\r\n                        anim = (this._sign > 0) ? this._actionMap.turnRight : this._actionMap.turnLeft;\r\n                    }\r\n                } else {\r\n                    if (this._act._walk) a = -this._sign;\r\n                    else if (this._act._walkback) { }\r\n                    else {\r\n                        a = -this._sign;\r\n                        anim = (this._sign > 0) ? this._actionMap.turnLeft : this._actionMap.turnRight;\r\n                    }\r\n                }\r\n            } else {\r\n                a = 1;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walkback) a = -1;\r\n                    if (!moving) anim = this._actionMap.turnLeft;\r\n                } else {\r\n                    if (this._act._walk) a = -1;\r\n                    if (!moving) { a = -1; anim = this._actionMap.turnRight; }\r\n                }\r\n                if (this._hasCam)\r\n                    this._camera.alpha = this._camera.alpha + this._rhsSign * turnAngle * a;\r\n            }\r\n            this._addToAvatarRotationY(turnAngle * a);\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _endFreeFall(): void {\r\n        this._movFallTime = 0;\r\n        this._inFreeFall = false;\r\n    }\r\n\r\n    //for how long has the av been falling while idle (not moving)\r\n    private _idleFallTime: number = 0;\r\n    private _doIdle(dt: number): ActionData {\r\n        if (this._grounded) {\r\n            return this._actionMap.idle;\r\n        }\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n        this._movFallTime = 0;\r\n        let anim: ActionData = this._actionMap.idle;\r\n\r\n        if (dt === 0) {\r\n            this._freeFallDist = 5;\r\n        } else {\r\n            const u: number = this._idleFallTime * this._gravity\r\n            this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n            this._idleFallTime = this._idleFallTime + dt;\r\n        }\r\n        //if displacement is less than 0.01(? need to verify further) then \r\n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\r\n        if (this._freeFallDist < 0.01) return anim;\r\n        const disp: Vector3 = new Vector3(0, -this._freeFallDist, 0);\r\n        // if (this._hasCam && this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        this._avatar.moveWithCollisions(disp);\r\n        if ((this._avatar.position.y > this._avStartPos.y) || (this._avatar.position.y === this._avStartPos.y)) {\r\n            //                this.grounded = true;\r\n            //                this.idleFallTime = 0;\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            let ng = this._isNearGround(actDisp);\r\n            //if (this._verticalSlope(actDisp) <= this._sl1) {\r\n            if (ng.slope <= this._sl1) {\r\n                this._groundIt();\r\n                this._avatar.position.copyFrom(this._avStartPos);\r\n            } else {\r\n                this._unGroundIt();\r\n                anim = this._actionMap.slideBack;\r\n            }\r\n\r\n            //this._groundIt();\r\n        } else if (this._avatar.position.y < this._avStartPos.y) {\r\n            //AV is going down. \r\n            //AV is either in free fall or is sliding along a downward slope\r\n            //\r\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n            //else it is on a slope\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                //AV is on slope\r\n                //Should AV continue to slide or stop?\r\n                //if slope is less steeper than accebtable then stop else slide\r\n                let ng = this._isNearGround(actDisp);\r\n                if (ng.slope <= this._sl1) {\r\n                    this._groundIt();\r\n                    this._avatar.position.copyFrom(this._avStartPos);\r\n                } else {\r\n                    this._unGroundIt();\r\n                    anim = this._actionMap.slideBack;\r\n                }\r\n            } else {\r\n                anim = this._actionMap.fall;\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _groundFrameCount = 0;\r\n    private _groundFrameMax = 10;\r\n    /**\r\n     * donot ground immediately\r\n     * wait few more frames\r\n     */\r\n    private _groundIt(): void {\r\n        this._groundFrameCount++;\r\n        if (this._groundFrameCount > this._groundFrameMax) {\r\n            this._grounded = true;\r\n            this._idleFallTime = 0;\r\n        }\r\n    }\r\n    private _unGroundIt() {\r\n        this._grounded = false;\r\n        this._groundFrameCount = 0;\r\n    }\r\n\r\n    private _savedCameraCollision: boolean = true;\r\n    private _inFP = false;\r\n    private _updateTargetValue() {\r\n        if (!this._hasCam) return;\r\n      \r\n        this._avatar.position.addToRef(this._cameraTarget, this._camera.target);\r\n\r\n        if (this._camera.radius > this._camera.lowerRadiusLimit) { if (this._cameraElastic || this._makeInvisible) this._handleObstruction(); }\r\n\r\n        //if user so desire, make the AV invisible if camera comes close to it\r\n        if (this._camera.radius <= this._camera.lowerRadiusLimit) {\r\n            if (!this._noFirstPerson && !this._inFP) {\r\n                this._makeMeshInvisible(this._avatar);\r\n                this._camera.checkCollisions = false;\r\n                this._saveMode = this._mode;\r\n                this._mode = 0;\r\n                this._inFP = true;\r\n            }\r\n        } else {\r\n            if (this._inFP) {\r\n                this._inFP = false;\r\n                this._mode = this._saveMode;\r\n                this._restoreVisiblity(this._avatar);\r\n                this._camera.checkCollisions = this._savedCameraCollision;\r\n            }\r\n        }\r\n    }\r\n\r\n    // make mesh and all its children invisible\r\n    // store their current visibility state so that we can restore them later on\r\n    private _makeMeshInvisible(mesh: Mesh) {\r\n\r\n        this._visiblityMap.set(mesh, mesh.visibility);\r\n        mesh.visibility = 0;\r\n\r\n        mesh.getChildMeshes(false, (n) => {\r\n            if (n instanceof Mesh) {\r\n                this._visiblityMap.set(n, n.visibility);\r\n                n.visibility = 0;\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    private _visiblityMap: Map<Mesh, int> = new Map();\r\n\r\n    //restore mesh visibility to previous state\r\n    private _restoreVisiblity(mesh: Mesh) {\r\n        mesh.visibility = this._visiblityMap.get(mesh);\r\n        mesh.getChildMeshes(false, (n) => {\r\n            if (n instanceof Mesh) n.visibility = this._visiblityMap.get(n);\r\n            return false;\r\n        });\r\n    }\r\n\r\n    private _ray: Ray = new Ray(Vector3.Zero(), Vector3.One(), 1);\r\n    private _rayDir: Vector3 = Vector3.Zero();\r\n    //camera seems to get stuck into things\r\n    //should move camera away from things by a value of cameraSkin\r\n    private _cameraSkin: number = 0.5;\r\n    private _prevPickedMeshes: AbstractMesh[];\r\n    private _pickedMeshes: AbstractMesh[] = new Array();;\r\n    private _makeInvisible = false;\r\n    private _elasticSteps = 50;\r\n    private _alreadyInvisible: AbstractMesh[];\r\n\r\n    /**\r\n     * The following method handles the use case wherein some mesh\r\n     * comes between the avatar and the camera thus obstructing the view\r\n     * of the avatar.\r\n     * Two ways this can be handled\r\n     * a) make the obstructing  mesh invisible\r\n     *   instead of invisible a better option would have been to make semi transparent.\r\n     *   Unfortunately, unlike mesh, mesh instances do not \"visibility\" setting)\r\n     *   Every alternate frame make mesh visible and invisible to give the impression of semi-transparent.\r\n     * b) move the camera in front of the obstructing mesh\r\n     */\r\n    private _handleObstruction() {\r\n\r\n        //get vector from av (camera.target) to camera\r\n        this._camera.position.subtractToRef(this._camera.target, this._rayDir);\r\n        //start ray from av to camera\r\n        this._ray.origin = this._camera.target;\r\n        this._ray.length = this._rayDir.length();\r\n        this._ray.direction = this._rayDir.normalize();\r\n\r\n\r\n        //do not pick a mesh if it is the avatar or any of its children (like attachments etc)\r\n        const pis: PickingInfo[] = this._scene.multiPickWithRay(this._ray, (mesh) => {\r\n            if (this._avChildren.includes(mesh)) return false;\r\n            if (mesh.isPickable) {\r\n                return true;\r\n            }else{ \r\n                return false;\r\n            }\r\n        });\r\n\r\n\r\n        if (this._makeInvisible) {\r\n            this._prevPickedMeshes = this._pickedMeshes;\r\n            if (pis.length > 0) {\r\n                this._pickedMeshes = new Array();\r\n                for (let pi of pis) {\r\n                    if (pi.pickedMesh.isVisible || this._prevPickedMeshes.includes(pi.pickedMesh)) {\r\n                        pi.pickedMesh.isVisible = false;\r\n                        this._pickedMeshes.push(pi.pickedMesh);\r\n                    }\r\n                }\r\n                for (let pm of this._prevPickedMeshes) {\r\n                    if (!this._pickedMeshes.includes(pm)) {\r\n                        pm.isVisible = true;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let pm of this._prevPickedMeshes) {\r\n                    pm.isVisible = true;\r\n                }\r\n                this._prevPickedMeshes.length = 0;\r\n            }\r\n        }\r\n\r\n        if (this._cameraElastic) {\r\n            if (pis.length > 0) {\r\n                // postion the camera in front of the mesh that is obstructing camera\r\n\r\n                //if only one obstruction and it is invisible then if it is not collidable or our camera is not collidable then do nothing\r\n                if ((pis.length == 1 && !this._isSeeAble(pis[0].pickedMesh)) && (!pis[0].pickedMesh.checkCollisions || !this._camera.checkCollisions)) return;\r\n\r\n                //if our camera is collidable then we donot want it to get stuck behind another collidable obsrtucting mesh\r\n                let pp: Vector3 = null;\r\n\r\n                //we will asume the order of picked meshes is from closest to avatar to furthest\r\n                //we should get the first one which is visible or invisible and collidable\r\n                for (let i = 0; i < pis.length; i++) {\r\n                    let pm = pis[i].pickedMesh;\r\n                    if (this._isSeeAble(pm)) {\r\n                        pp = pis[i].pickedPoint;\r\n                        break;\r\n                    } else if (pm.checkCollisions) {\r\n                        pp = pis[i].pickedPoint;\r\n                        break;\r\n                    }\r\n                }\r\n                if (pp == null) return;\r\n\r\n                const c2p: Vector3 = this._camera.position.subtract(pp);\r\n                //note that when camera is collidable, changing the orbital camera radius may not work.\r\n                //changing the radius moves the camera forward (with collision?) and collision can interfere with movement\r\n                //\r\n                //in every cylce we are dividing the distance to tarvel by same number of steps.\r\n                //as we get closer to destination the speed will thus slow down.\r\n                //when just 1 unit distance left, lets snap to the final position.\r\n                //when calculating final position make sure the camera does not get stuck at the pickposition especially\r\n                //if collision is on\r\n\r\n                const l: number = c2p.length();\r\n                if (this._camera.checkCollisions) {\r\n                    let step: Vector3;\r\n                    if (l <= 1) {\r\n                        step = c2p.addInPlace(c2p.normalizeToNew().scaleInPlace(this._cameraSkin));\r\n                    } else {\r\n                        step = c2p.normalize().scaleInPlace(l / this._elasticSteps);\r\n                    }\r\n                    this._camera.position = this._camera.position.subtract(step);\r\n                } else {\r\n                    let step: number;\r\n                    if (l <= 1) step = l + this._cameraSkin; else step = l / this._elasticSteps;\r\n                    this._camera.radius = this._camera.radius - (step);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //how many ways can a mesh be invisible?\r\n    private _isSeeAble(mesh: AbstractMesh): boolean {\r\n        if (!mesh.isVisible) return false;\r\n        if (mesh.visibility == 0) return false;\r\n        if (mesh.material != null && mesh.material.alphaMode != 0 && mesh.material.alpha == 0) return false;\r\n        return true;\r\n        //what about vertex color? groan!\r\n    }\r\n\r\n\r\n    private _move: boolean = false;\r\n    public anyMovement(): boolean {\r\n        return (this._act._walk || this._act._walkback || this._act._turnLeft || this._act._turnRight || this._act._stepLeft || this._act._stepRight);\r\n    }\r\n\r\n    private _onKeyDown(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        if (e.repeat) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case this._actionMap.idleJump.key:\r\n                this._act._jump = true;\r\n                break;\r\n            case \"capslock\":\r\n                this._act._speedMod = !this._act._speedMod;\r\n                break;\r\n            case \"shift\":\r\n                this._act._speedMod = true;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk.key:\r\n                // console.log(\"walk\");\r\n                this._act._walk = true;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft.key:\r\n                // console.log(\"turn left\");\r\n                this._act._turnLeft = true;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight.key:\r\n                // console.log(\"turn right\");\r\n                this._act._turnRight = true;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack.key:\r\n                // console.log(\"walk back\");\r\n                this._act._walkback = true;\r\n                break;\r\n            case this._actionMap.strafeLeft.key:\r\n                // console.log(\"strafe left\");\r\n                this._act._stepLeft = true;\r\n                break;\r\n            case this._actionMap.strafeRight.key:\r\n                // console.log(\"strafe right\");\r\n                this._act._stepRight = true;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _onKeyUp(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case \"shift\":\r\n                this._act._speedMod = false;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk.key:\r\n                this._act._walk = false;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft.key:\r\n                this._act._turnLeft = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight.key:\r\n                this._act._turnRight = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack.key:\r\n                this._act._walkback = false;\r\n                break;\r\n            case this._actionMap.strafeLeft.key:\r\n                this._act._stepLeft = false;\r\n                break;\r\n            case this._actionMap.strafeRight.key:\r\n                this._act._stepRight = false;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _ekb: boolean = true;\r\n    public isKeyBoardEnabled(): boolean {\r\n        return this._ekb;\r\n    }\r\n    public enableKeyBoard(b: boolean) {\r\n        this._ekb = b;\r\n        if (b) {\r\n            this._addkeylistener();\r\n        } else {\r\n            this._removekeylistener();\r\n        }\r\n    }\r\n\r\n    private _addkeylistener() {\r\n        let canvas: HTMLCanvasElement = this._scene.getEngine().getRenderingCanvas();\r\n        canvas.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n        canvas.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    private _removekeylistener() {\r\n        let canvas: HTMLCanvasElement = this._scene.getEngine().getRenderingCanvas();\r\n        canvas.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n        canvas.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    // control movement by commands rather than keyboard.\r\n    public walk(b: boolean) {\r\n        this._act.reset();\r\n        this._act._walk = b;\r\n    }\r\n    public walkBack(b: boolean) {\r\n        this._act.reset();\r\n        this._act._walkback = b;\r\n    }\r\n    public walkBackFast(b: boolean) {\r\n        this._act.reset();\r\n        this._act._walkback = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public run(b: boolean) {\r\n        this._act.reset();\r\n        this._act._walk = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnLeft(b: boolean) {\r\n        this._act.reset();\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnLeftFast(b: boolean) {\r\n        this._act.reset();\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnRight(b: boolean) {\r\n        this._act.reset();\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnRightFast(b: boolean) {\r\n        this._act.reset();\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeLeft(b: boolean) {\r\n        this._act.reset();\r\n        this._act._stepLeft = b;\r\n    }\r\n    public strafeLeftFast(b: boolean) {\r\n        this._act.reset();\r\n        this._act._stepLeft = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeRight(b: boolean) {\r\n        this._act.reset();\r\n        this._act._stepRight = b;\r\n    }\r\n    public strafeRightFast(b: boolean) {\r\n        this._act.reset();\r\n        this._act._stepRight = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public jump() {\r\n        this._act.reset();\r\n        this._act._jump = true;\r\n    }\r\n\r\n    public fall() {\r\n        this._act.reset();\r\n        this._grounded = false;\r\n    }\r\n\r\n    public idle() {\r\n        this._act.reset();\r\n    }\r\n\r\n    private _act: _Action;\r\n    private _renderer: () => void;\r\n    private _handleKeyUp: (e) => void;\r\n    private _handleKeyDown: (e) => void;\r\n    private _isAG: boolean = false;\r\n    public isAg() {\r\n        return this._isAG;\r\n    }\r\n\r\n\r\n\r\n\r\n    private _findSkel(n: Node): Skeleton {\r\n        let root = this._root(n);\r\n\r\n        if (root instanceof Mesh && root.skeleton) return root.skeleton;\r\n\r\n        //find all child meshes which have skeletons\r\n        let ms = root.getChildMeshes(\r\n            false,\r\n            (cm) => {\r\n                if (cm instanceof Mesh) {\r\n                    if (cm.skeleton) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            });\r\n\r\n        //return the skeleton of the first child mesh\r\n        if (ms.length > 0) return ms[0].skeleton; else return null;\r\n\r\n    }\r\n\r\n    private _root(tn: Node): Node {\r\n        if (tn.parent == null) return tn;\r\n        return this._root(tn.parent);\r\n    }\r\n\r\n    private _getAbstractMeshChildren(tn: Node): AbstractMesh[] {\r\n        let ms: AbstractMesh[] = new Array();\r\n        if (tn instanceof AbstractMesh) ms.push(tn);\r\n        tn.getChildren((cm) => {\r\n            if (cm instanceof AbstractMesh) ms.push(cm);\r\n            return false;\r\n        },\r\n        false)\r\n        return ms;  \r\n    }\r\n\r\n    public setAvatar(avatar: Mesh, faceForward: boolean = false): boolean {\r\n\r\n        let rootNode = this._root(avatar);\r\n        if (rootNode instanceof Mesh) {\r\n            this._avatar = rootNode;\r\n        } else {\r\n            console.error(\"Cannot move this mesh. The root node of the mesh provided is not a mesh\");\r\n            return false;\r\n        }\r\n        this._avChildren = this._getAbstractMeshChildren(rootNode);\r\n        this._skeleton = this._findSkel(avatar);\r\n        this._isAG = this._containsAG(avatar, this._scene.animationGroups, true);\r\n\r\n        this._actionMap.reset();\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private _ellipsoid:TransformNode = null;\r\n    public showEllipsoid(show:boolean) {\r\n        if (!show){\r\n            if (this._ellipsoid != null) this._ellipsoid.dispose();\r\n            this._ellipsoid = null;\r\n            if (this._rayLine != null) { this._rayLine.dispose(); this._rayLine = null; }\r\n            return;\r\n        }\r\n        if (this._ellipsoid !== null) return;\r\n        let ellipsoid:TransformNode = new TransformNode(\"ellipsoid\", this._scene);\r\n        \r\n        let a = this._avatar.ellipsoid.x;\r\n        let b = this._avatar.ellipsoid.y;\r\n\r\n        const points = [];\r\n        for(let theta = -Math.PI/2; theta < Math.PI/2; theta += Math.PI/36) {\r\n            points.push(new BABYLON.Vector3(0, b * Math.sin(theta), a * Math.cos(theta)));\r\n        }\r\n    \r\n        const ellipse : LinesMesh[] = [];\r\n        ellipse[0] = MeshBuilder.CreateLines(\"e\", {points:points}, this._scene);\r\n        ellipse[0].color = Color3.Red();\r\n        ellipse[0].parent = ellipsoid;\r\n        ellipse[0].isPickable = false;\r\n        const steps = 12;\r\n        const dTheta = 2 * Math.PI / steps; \r\n        for(let i = 1; i < steps; i++) {\r\n                ellipse[i] = ellipse[0].clone(\"el\" + i);\r\n                ellipse[i].parent = ellipsoid;\r\n                ellipse[i].rotation.y = i * dTheta;\r\n                ellipse[i].isPickable = false;\r\n        }\r\n        ellipsoid.parent = this._avatar;\r\n        ellipsoid.position = this._avatar.ellipsoidOffset;\r\n        this._ellipsoid= ellipsoid;\r\n    }\r\n\r\n    public getAvatar() {\r\n        return this._avatar;\r\n    }\r\n\r\n    // force a skeleton to be the avatar skeleton\r\n    // should not be calling this normally\r\n    public setAvatarSkeleton(skeleton: Skeleton) {\r\n        this._skeleton = skeleton;\r\n\r\n\r\n        if (this._skeleton != null && this._skelDrivenByAG(skeleton)) this._isAG = true; else this._isAG = false;\r\n\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n    }\r\n\r\n\r\n    // this check if any of this skeleton animations is referenced by any targetedAnimation in any of the animationgroup in the scene.\r\n    private _skelDrivenByAG(skeleton: Skeleton) {\r\n        return skeleton.animations.some(sa => this._scene.animationGroups.some(ag => ag.children.some(ta => ta.animation == sa)));\r\n    }\r\n\r\n    public getSkeleton() {\r\n        return this._skeleton;\r\n    }\r\n\r\n    // does this character have any animations ?\r\n    // remember we can use meshes without anims as characters too\r\n    private _hasAnims: boolean = false;\r\n    private _hasCam: boolean = true;\r\n    //av children will be used if elastic camera is set to true\r\n    //pick collision with children will ignored then\r\n    private _avChildren:AbstractMesh[];\r\n\r\n    /**\r\n     * The avatar/character can be made up of multiple meshes arranged in a hierarchy.\r\n     * As such we will pick the root of the hierarchy as the avatar.\r\n     * The root should be a mesh as otherwise we cannot move it with moveWithCollision() method.\r\n     * \r\n     * Mutiple meshes in the hierarchy may have skeletons (if two or more meshes have skeleton then\r\n     * the skeleton will mostly likely be the same). \r\n     * So we will pick as avatar skeleton, the  skeleton of the first mesh in the hierachy which has\r\n     * a skeleton \r\n     * \r\n     * @param avatar \r\n     * @param camera \r\n     * @param scene \r\n     * @param actionMap/animationGroupMap \r\n     *        maps actions to animations and other data like speed,sound etc \r\n     *        or \r\n     *        for backward compatibility could be AnimationGroup Map\r\n     * @param faceForward \r\n     */\r\n    constructor(avatar: Mesh, camera: ArcRotateCamera, scene: Scene, actionMap?: {}, faceForward = false) {\r\n\r\n        this._camera = camera;\r\n\r\n        //if camera is null assume this would be used to control an NPC\r\n        //we cannot use mode 0 as that is dependent on camera being present. so force mode 1 (TODO revist this)\r\n        if (this._camera == null) {\r\n            this._hasCam = false;\r\n            this.setMode(1);\r\n        }\r\n        this._scene = scene;\r\n\r\n        let success = this.setAvatar(avatar, faceForward);\r\n        if (!success) {\r\n            console.error(\"unable to set avatar\");\r\n        }\r\n\r\n        let dataType: string = null;\r\n        if (actionMap != null) {\r\n            dataType = this.setActionMap(<ActionMap>actionMap);\r\n        }\r\n\r\n        //try to use the existing avatar animations\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n        //animation groups\r\n        if (this._isAG) {\r\n            //TODO\r\n        }\r\n\r\n        if (this._hasCam) this._savedCameraCollision = this._camera.checkCollisions;\r\n\r\n        // this._avatar.onCollideObservable.add(\r\n        //     function(m,evt){\r\n        //         let msg = \"Collision with: \"+m.name;\r\n        //         console.log(m);\r\n        //         console.log(evt);\r\n        //     }\r\n        // );    \r\n\r\n\r\n        this._act = new _Action();\r\n\r\n        this._renderer = () => { this._moveAVandCamera() };\r\n        this._handleKeyUp = (e) => { this._onKeyUp(e) };\r\n        this._handleKeyDown = (e) => { this._onKeyDown(e) };\r\n    }\r\n}\r\n\r\n\r\n\r\nclass _Action {\r\n\r\n    public _walk: boolean = false;\r\n    public _walkback: boolean = false;\r\n    public _turnRight: boolean = false;\r\n    public _turnLeft: boolean = false;\r\n    public _stepRight: boolean = false;\r\n    public _stepLeft: boolean = false;\r\n    public _jump: boolean = false;\r\n\r\n    // speed modifier - changes speed of movement\r\n    public _speedMod: boolean = false;\r\n\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this._walk = false;\r\n        this._walkback = false;\r\n        this._turnRight = false;\r\n        this._turnLeft = false;\r\n        this._stepRight = false;\r\n        this._stepLeft = false;\r\n        this._jump = false;\r\n        this._speedMod = false;\r\n    }\r\n}\r\n\r\nexport class ActionData {\r\n    public id: string;\r\n    public speed: number;\r\n    //_ds default speed.  speed is set to this on reset\r\n    public ds: number;\r\n    public sound: Sound;\r\n    public key: string;\r\n    //_dk defailt key\r\n    public dk: string;\r\n\r\n    //animation data\r\n    //if _ag is null then assuming animation range and use _name to play animationrange\r\n    //instead of name maybe call it arName?\r\n    public name: string = \"\";\r\n    public ag: AnimationGroup;\r\n    public loop: boolean = true;\r\n    public rate: number = 1;\r\n\r\n    public exist: boolean = false;\r\n\r\n    public constructor(id?: string, speed = 1, key?: string) {\r\n        this.id = id;\r\n        this.speed = speed;\r\n        this.ds = speed;\r\n        this.key = key;\r\n        this.dk = key;\r\n    }\r\n\r\n    public reset() {\r\n        this.name = \"\";\r\n        this.speed = this.ds;\r\n        this.key = this.dk;\r\n        this.loop = true;\r\n        this.rate = 1;\r\n        this.sound = null;\r\n        this.exist = false;\r\n    }\r\n\r\n}\r\n\r\nexport const Actions = {\r\n    WALK: \"walk\",\r\n    WALKBACK: \"walkBack\",\r\n    WALKBACKFAST: \"walkBackFast\",\r\n    IDLE: \"idle\",\r\n    IDLEJUMP: \"idleJump\",\r\n    RUN: \"run\",\r\n    RUNJUMP: \"runJump\",\r\n    FALL: \"fall\",\r\n    TURNLEFT: \"turnLeft\",\r\n    TURNLEFTFAST: \"turnLeftFast\",\r\n    TURNRIGHT: \"turnRight\",\r\n    TURNRIGHTFAST: \"turnRightFast\",\r\n    STRAFELEFT: \"strafeLeft\",\r\n    STRAFELEFTFAST: \"strafeLeftFast\",\r\n    STRAFERIGHT: \"strafeRight\",\r\n    STRAFERIGHTFAST: \"strafeRightFast\",\r\n    SLIDEBACK: \"slideBack\",\r\n    getAll: () => Object.values(Actions).filter(v => typeof v === \"string\")\r\n} as const\r\n \r\n//not really a \"Map\"\r\nexport class ActionMap {\r\n    public walk = new ActionData(Actions.WALK, 3, \"w\");\r\n    public walkBack = new ActionData(Actions.WALKBACK, 1.5, \"s\");\r\n    public walkBackFast = new ActionData(Actions.WALKBACKFAST, 3, \"na\");\r\n    public idle = new ActionData(Actions.IDLE, 0, \"na\");\r\n    public idleJump = new ActionData(Actions.IDLEJUMP, 6, \" \");\r\n    public run = new ActionData(Actions.RUN, 6, \"na\");\r\n    public runJump = new ActionData(Actions.RUNJUMP, 6, \"na\");\r\n    public fall = new ActionData(Actions.FALL, 0, \"na\");\r\n    public turnLeft = new ActionData(Actions.TURNLEFT, Math.PI / 8, \"a\");\r\n    public turnLeftFast = new ActionData(Actions.TURNLEFTFAST, Math.PI / 4, \"na\");\r\n    public turnRight = new ActionData(Actions.TURNRIGHT, Math.PI / 8, \"d\");\r\n    public turnRightFast = new ActionData(Actions.TURNRIGHTFAST, Math.PI / 4, \"na\");\r\n    public strafeLeft = new ActionData(Actions.STRAFELEFT, 1.5, \"q\");\r\n    public strafeLeftFast = new ActionData(Actions.STRAFELEFTFAST, 3, \"na\");\r\n    public strafeRight = new ActionData(Actions.STRAFERIGHT, 1.5, \"e\");\r\n    public strafeRightFast = new ActionData(Actions.STRAFERIGHTFAST, 3, \"na\");\r\n    public slideBack = new ActionData(Actions.SLIDEBACK, 0, \"na\");\r\n\r\n    public reset() {\r\n        let keys: string[] = Object.keys(this);\r\n        for (let key of keys) {\r\n            let act = this[key];\r\n            if (!(act instanceof ActionData)) continue;\r\n            act.reset()\r\n        }\r\n    }\r\n\r\n    public actionNames():string[]{\r\n        let ids: string[] = new Array();\r\n        let keys: string[] = Object.keys(this);\r\n        for (let key of keys) {\r\n            let act = this[key];\r\n            if (!(act instanceof ActionData)) continue;\r\n            ids.push(act.id);\r\n        }\r\n        return ids;\r\n    }\r\n};\r\n\r\nexport class CCSettings {\r\n    public faceForward: boolean;\r\n    public gravity: number;\r\n    public minSlopeLimit: number;\r\n    public maxSlopeLimit: number;\r\n    public stepOffset: number;\r\n    public cameraElastic: boolean = true;\r\n    public elasticSteps: number;\r\n    public makeInvisble: boolean = true;\r\n    public cameraTarget: Vector3 = Vector3.Zero();\r\n    public noFirstPerson: boolean = false;\r\n    public topDown: boolean = true;\r\n    //turningOff takes effect only when topDown is false\r\n    public turningOff: boolean = true;\r\n    public keyboard: boolean = true;\r\n    public sound: Sound;\r\n    public animBlend: number;\r\n    public ellipsoid:Vector3;   \r\n    public ellipsoidOffset:Vector3;\r\n}\r\n"],"names":["root","factory","exports","module","require","define","amd","a","i","self","__WEBPACK_EXTERNAL_MODULE__247__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","avatar","camera","scene","actionMap","faceForward","_avatar","_skeleton","_gravity","_minSlopeLimit","_maxSlopeLimit","_sl1","Math","PI","this","_sl2","_stepOffset","_actionMap","ActionMap","_cameraElastic","_cameraTarget","Vector3","_noFirstPerson","_down","_mode","_saveMode","_isLHS_RHS","_signLHS_RHS","_started","_stopAnim","_prevActData","_avStartPos","_prevPickY","_grounded","_freeFallDist","_inFreeFall","_wasWalking","_wasRunning","_moveVector","_soundLoopTime","_sndId","_jumpStartPosY","_jumpTime","_movFallTime","_sign","_isTurning","_noRot","_steps","_stepHigh","_rayLine","_lineOptions","_idleFallTime","_groundFrameCount","_groundFrameMax","_savedCameraCollision","_inFP","_visiblityMap","Map","_ray","Ray","_rayDir","_cameraSkin","_pickedMeshes","Array","_makeInvisible","_elasticSteps","_move","_ekb","_isAG","_ellipsoid","_hasAnims","_hasCam","_camera","setMode","_scene","setAvatar","console","error","setActionMap","_checkAnimRanges","checkCollisions","_act","_Action","_renderer","_moveAVandCamera","_handleKeyUp","e","_onKeyUp","_handleKeyDown","_onKeyDown","getScene","setSlopeLimit","minSlopeLimit","maxSlopeLimit","setStepOffset","stepOffset","setWalkSpeed","walk","speed","setRunSpeed","run","setBackSpeed","walkBack","setBackFastSpeed","walkBackFast","setJumpSpeed","idleJump","runJump","setLeftSpeed","strafeLeft","setLeftFastSpeed","strafeLeftFast","setRightSpeed","strafeRight","setRightFastSpeed","setTurnSpeed","turnLeft","turnRight","setTurnFastSpeed","turnLeftFast","turnRightFast","setGravity","setAnimationGroups","agMap","exist","ag","stop","setAnimationRanges","arMap","inActMap","inActData","keys","ccActionName","ccActData","ActionData","id","AnimationGroup","name","loop","rate","sound","_checkFastAnims","getActionMap","map","actDataI","actDataO","getSettings","ccs","CCSettings","isFaceForward","topDown","getMode","turningOff","isTurningOff","cameraTarget","clone","cameraElastic","elasticSteps","makeInvisble","gravity","keyboard","noFirstPerson","_stepSound","animBlend","_animBlend","ellipsoid","ellipsoidOffset","setSettings","setFaceForward","setTurningOff","setCameraTarget","setCameraElasticity","setElasticiSteps","makeObstructionInvisible","enableKeyBoard","setNoFirstPerson","setSound","enableBlending","_setAnim","anim","animName","getAnimationRange","act","ar","targetedAnimations","ta","animation","blendingSpeed","disableBlending","setWalkAnim","rangeName","setRunAnim","setWalkBackAnim","_copySlowAnims","setWalkBackFastAnim","setSlideBackAnim","slideBack","setIdleAnim","idle","setTurnRightAnim","setTurnRightFastAnim","setTurnLeftAnim","setTurnLeftFastAnim","setStrafeRightAnim","strafeRightFast","setStrafeRightFastAnim","setStrafeLeftAnim","setStrafeLeftFastAnim","setIdleJumpAnim","setRunJumpAnim","setFallAnim","fall","ccActionNames","attachToMesh","setWalkKey","toLowerCase","setWalkBackKey","setTurnLeftKey","setTurnRightKey","setStrafeLeftKey","setStrafeRightKey","setJumpKey","b","v","copyFrom","cameraCollisionChanged","skel","f","s","_getAvatarRotationY","rotationQuaternion","toEulerAngles","y","rotation","_setAvatarRotationY","angle","euler","Quaternion","x","z","_addToAvatarRotationY","_setRHS","mesh","meshMatrix","getWorldMatrix","_localX","m","_localY","_localZ","actualZ","_ff","_rhsSign","useRightHandedSystem","_av2cam","_ffSign","checkAGs","_containsAG","node","ags","fromRoot","ns","_getRoot","getChildren","TransformNode","indexOf","target","tn","parent","start","reset","_updateTargetValue","_addkeylistener","registerBeforeRender","unregisterBeforeRender","_removekeylistener","pauseAnim","stopAnimation","clearInterval","resumeAnim","_isAvFacingCamera","forward","position","subtract","actData","dt","getEngine","getDeltaTime","_jump","_doJump","anyMovement","_doMove","_doIdle","c","fps","framePerSecond","to","from","beginAnimation","getAnimations","play","setInterval","abs","disp","forwardDist","jumpDist","normalize","scaleToRef","_calcJumpDist","moveWithCollisions","length","_endJump","actDisp","_areVectorsEqual","_isNearGround","slope","v1","v2","p","_verticalSlope","atan","sqrt","u","moving","actdata","_rotateAV2C","_rotateAVnC","sign","horizDist","_speedMod","calcMovePOV","_walk","_ng","hit","_slp","_endFreeFall","fwd","upDist","up","fact","origin","addToRef","direction","_drawLines","add","pi","pickWithRay","_avChildren","includes","getNormal","asin","pickedMesh","pickedPoint","_isNearGround_old","pis","multiPickWithRay","pt1","pt2","myPoints","points","updatable","MeshBuilder","instance","ca","alpha","_turnRight","_turnLeft","_walkback","_stepLeft","_stepRight","turnAngle","_groundIt","_unGroundIt","radius","lowerRadiusLimit","_handleObstruction","_makeMeshInvisible","_restoreVisiblity","set","visibility","getChildMeshes","Mesh","subtractToRef","isPickable","_prevPickedMeshes","isVisible","push","pm","_isSeeAble","pp","c2p","l","step","addInPlace","normalizeToNew","scaleInPlace","material","alphaMode","repeat","isKeyBoardEnabled","canvas","getRenderingCanvas","addEventListener","removeEventListener","jump","isAg","_findSkel","_root","skeleton","ms","cm","_getAbstractMeshChildren","AbstractMesh","rootNode","animationGroups","showEllipsoid","show","dispose","theta","BABYLON","sin","cos","ellipse","color","Color3","dTheta","getAvatar","setAvatarSkeleton","_skelDrivenByAG","animations","some","sa","children","getSkeleton","ds","dk","Actions","WALK","WALKBACK","WALKBACKFAST","IDLE","IDLEJUMP","RUN","RUNJUMP","FALL","TURNLEFT","TURNLEFTFAST","TURNRIGHT","TURNRIGHTFAST","STRAFELEFT","STRAFELEFTFAST","STRAFERIGHT","STRAFERIGHTFAST","SLIDEBACK","getAll","values","filter","actionNames","ids"],"sourceRoot":""}