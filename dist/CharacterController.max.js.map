{"version":3,"file":"CharacterController.max.js","mappings":"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","sources":["webpack://babylonjs-charactercontroller/webpack/universalModuleDefinition","webpack://babylonjs-charactercontroller/external umd {\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\",\"root\":\"BABYLON\"}","webpack://babylonjs-charactercontroller/webpack/bootstrap","webpack://babylonjs-charactercontroller/webpack/runtime/compat get default export","webpack://babylonjs-charactercontroller/webpack/runtime/define property getters","webpack://babylonjs-charactercontroller/webpack/runtime/hasOwnProperty shorthand","webpack://babylonjs-charactercontroller/webpack/runtime/make namespace object","webpack://babylonjs-charactercontroller/./src/CharacterController.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babylonjs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babylonjs\")) : factory(root[\"BABYLON\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, (__WEBPACK_EXTERNAL_MODULE_babylonjs__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {\r\n    Skeleton,\r\n    ArcRotateCamera,\r\n    Vector3,\r\n    Mesh,\r\n    Node,\r\n    Scene,\r\n    Ray,\r\n    PickingInfo,\r\n    AnimationGroup,\r\n    TransformNode,\r\n    TargetedAnimation,\r\n    Matrix,\r\n    DeepImmutable,\r\n    AbstractMesh,\r\n    PlaySoundAction,\r\n    InstancedMesh,\r\n    Sound,\r\n    AnimationRange,\r\n    Animatable,\r\n    AnimationEvent,\r\n    int,\r\n    LinesMesh,\r\n    MeshBuilder,\r\n    Color3\r\n} from \"babylonjs\";\r\n\r\n\r\nexport class CharacterController {\r\n\r\n    private _avatar: Mesh = null;\r\n    private _skeleton: Skeleton = null;\r\n    private _camera: ArcRotateCamera;\r\n    private _scene: Scene;\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n\r\n    private _gravity: number = 9.8;\r\n    //slopeLimit in degrees\r\n    private _minSlopeLimit: number = 30;\r\n    private _maxSlopeLimit: number = 45;\r\n    //slopeLimit in radians\r\n    private _sl1: number = Math.PI * this._minSlopeLimit / 180;\r\n    private _sl2: number = Math.PI * this._maxSlopeLimit / 180;\r\n\r\n    //The av will step up a stair only if it is closer to the ground than the indicated value.\r\n    private _stepOffset: number = 0.25;\r\n    //toal amount by which the av has moved up\r\n    private _vMoveTot: number = 0;\r\n    private _pauseCam:boolean = false;\r\n    //position of av when it started moving up\r\n    private _vMovStartPos: Vector3 = Vector3.Zero();\r\n\r\n\r\n    private _actionMap: ActionMap = new ActionMap();\r\n\r\n    private _cameraElastic: boolean = true;\r\n    private _cameraTarget: Vector3 = Vector3.Zero();\r\n    //should we go into first person view when camera is near avatar (radius is lowerradius limit)\r\n    private _noFirstPerson: boolean = false;\r\n\r\n    private _down: Vector3 = Vector3.DownReadOnly;\r\n\r\n\r\n    public setSlopeLimit(minSlopeLimit: number, maxSlopeLimit: number) {\r\n        this._minSlopeLimit = minSlopeLimit;\r\n        this._maxSlopeLimit = maxSlopeLimit;\r\n\r\n        this._sl1 = Math.PI * this._minSlopeLimit / 180;\r\n        this._sl2 = Math.PI * this._maxSlopeLimit / 180;\r\n    }\r\n\r\n    /**\r\n     * The av will step up a stair only if it is closer to the ground than the indicated value.\r\n     * Default value is 0.25 m\r\n     */\r\n    public setStepOffset(stepOffset: number) {\r\n        this._stepOffset = stepOffset;\r\n    }\r\n\r\n    public setWalkSpeed(n: number) {\r\n        this._actionMap.walk.speed = n;\r\n    }\r\n    public setRunSpeed(n: number) {\r\n        this._actionMap.run.speed = n;\r\n    }\r\n    public setBackSpeed(n: number) {\r\n        this._actionMap.walkBack.speed = n;\r\n    }\r\n    public setBackFastSpeed(n: number) {\r\n        this._actionMap.walkBackFast.speed = n;\r\n    }\r\n    public setJumpSpeed(n: number) {\r\n        this._actionMap.idleJump.speed = n;\r\n        this._actionMap.runJump.speed = n;\r\n    }\r\n    public setLeftSpeed(n: number) {\r\n        this._actionMap.strafeLeft.speed = n;\r\n    }\r\n    public setLeftFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast.speed = n;\r\n    }\r\n    public setRightSpeed(n: number) {\r\n        this._actionMap.strafeRight.speed = n;\r\n    }\r\n    public setRightFastSpeed(n: number) {\r\n        this._actionMap.strafeLeftFast.speed = n;\r\n    }\r\n    // get turnSpeed in degrees per second.\r\n    // store in radians per second\r\n    public setTurnSpeed(n: number) {\r\n        this._actionMap.turnLeft.speed = n * Math.PI / 180;\r\n        this._actionMap.turnRight.speed = n * Math.PI / 180;\r\n    }\r\n    public setTurnFastSpeed(n: number) {\r\n        this._actionMap.turnLeftFast.speed = n * Math.PI / 180;\r\n        this._actionMap.turnRightFast.speed = n * Math.PI / 180;\r\n    }\r\n    public setGravity(n: number) {\r\n        this._gravity = n;\r\n    }\r\n\r\n    /**\r\n     * Use this to provide animationGroups to the character controller.\r\n     * Provide the AnimationGroups using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animationGroup.\r\n     * Example:\r\n     * let myWalkAnimationGroup:AnimationGroup = ...;\r\n     * let agMap:{} = {\r\n     *  \"walk\":myWalkAnimationGroup,\r\n     *  \"run\" : {\"ag\":myRunAnimationGroup,\"rate\":1},\r\n     *  \"idle\" : {\"ag\":myIdleAnimationGroup,\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     *   ....\r\n     * }\r\n     * \r\n     * @param agMap a map of character controller animation name to animationGroup\r\n     */\r\n    public setAnimationGroups(agMap: {}) {\r\n        if (this._prevActData != null && this._prevActData.exist) this._prevActData.ag.stop();\r\n        this._isAG = true;\r\n        this.setActionMap(<ActionMap>agMap);\r\n    }\r\n\r\n    /**\r\n     * Use this to provide AnimationRanges to the character controller.\r\n     * Provide the AnimationRanges using a Map\r\n     * In this Map the key would be the character controller animation name and\r\n     * the key value would be the animation range name or an object with animation range data.\r\n     * example:\r\n     * let arMap = {\r\n     *  \"walk\":\"myWalk\",\r\n     *  \"run\" : {\"name\":\"myRun\",\"rate\":1},\r\n     *  \"idle\" : {\"name\":\"myIdle\",\"loop\":true,\"rate\":1},\r\n     *  ....\r\n     * }\r\n     * \r\n     * @param arMap a map of character controller animation name to animationRange data\r\n     */\r\n\r\n    public setAnimationRanges(arMap: {}) {\r\n        this._isAG = false;\r\n        this.setActionMap(<ActionMap>arMap);\r\n    }\r\n\r\n    /**\r\n     * updates action data in the cc actionMap\r\n     * with action data from the provided/input actionMap \r\n     * \r\n     * \r\n     * return \"ar\" or \"ag\" depending on if the data provided\r\n     * was animation range or animation group data respt.\r\n     * \r\n     * TODO should validate provided data.\r\n     * In other words if animation range provided make sure\r\n     * the range exist in the skeleton\r\n     * or if animation group provided make sure the animation group\r\n     * can be played on this avataor\r\n     * \r\n     * @param inActMap \r\n     * @returns \r\n     */\r\n    public setActionMap(inActMap: ActionMap): string {\r\n        let agMap: boolean = false;\r\n        let inActData: ActionData;\r\n\r\n\r\n        let ccActionNames: string[] = Object.keys(this._actionMap);\r\n        for (let ccActionName of ccActionNames) {\r\n            let ccActData = this._actionMap[ccActionName];\r\n            //some keys could map to functions (like reset())\r\n            if (!(ccActData instanceof ActionData)) continue;\r\n            ccActData.exist = false;\r\n\r\n            inActData = inActMap[ccActData.id];\r\n            //in previous version of cc the key value was AnimationGroup rather than ActionData\r\n            //lets accomodate that for backward compatibility\r\n            if (inActData != null) {\r\n                if (inActData instanceof AnimationGroup) {\r\n                    ccActData.ag = inActData;\r\n                    ccActData.name = ccActData.ag.name;\r\n                    ccActData.exist = true;\r\n                    agMap = true;\r\n                    this._hasAnims = true;\r\n                } else if (inActData.exist) {\r\n                    this._hasAnims = true;\r\n                    ccActData.exist = true;\r\n                    if (inActData instanceof Object) {\r\n                        if (inActData.ag) {\r\n                            ccActData.ag = inActData.ag;\r\n                            agMap = true;\r\n                        }\r\n                        if (inActData.name) {\r\n                            ccActData.name = inActData.name;\r\n                        }\r\n                        if (inActData.loop != null) ccActData.loop = inActData.loop;\r\n                        if (inActData.rate) ccActData.rate = inActData.rate;\r\n                        if (inActData.speed) ccActData.speed = inActData.speed;\r\n                        // if (actDataI.key) actDataO.key = actDataI.key;\r\n                        if (inActData.sound) ccActData.sound = inActData.sound;\r\n                    } else {\r\n                        ccActData.name = inActData;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n        //force to play new anims\r\n        this._prevActData = null;\r\n        if (agMap) return \"ag\"; else return \"ar\";\r\n    }\r\n\r\n    public getActionMap(): ActionMap {\r\n        let map: ActionMap = new ActionMap();\r\n\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let actDataI = this._actionMap[key];\r\n\r\n            if (!(actDataI instanceof ActionData)) continue;\r\n            if (!actDataI.exist) continue;\r\n\r\n            let actDataO: ActionData = map[actDataI.id];\r\n            actDataO.ag = actDataI.ag;\r\n            actDataO.name = actDataI.name;\r\n            actDataO.loop = actDataI.loop;\r\n            actDataO.rate = actDataI.rate;\r\n            actDataO.speed = actDataI.speed;\r\n            actDataO.key = actDataI.key;\r\n            actDataO.sound = actDataI.sound;\r\n            actDataO.exist = actDataI.exist;\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    public getSettings(): CCSettings {\r\n        let ccs: CCSettings = new CCSettings();\r\n        ccs.faceForward = this.isFaceForward();\r\n        ccs.topDown = this.getMode() == 1 ? true : false;\r\n        ccs.turningOff = this.isTurningOff();\r\n        ccs.cameraTarget = this._cameraTarget.clone();\r\n        ccs.cameraElastic = this._cameraElastic;\r\n        ccs.elasticSteps = this._elasticSteps;\r\n        ccs.makeInvisble = this._makeInvisible;\r\n        ccs.gravity = this._gravity;\r\n        ccs.keyboard = this._ekb;\r\n        ccs.maxSlopeLimit = this._maxSlopeLimit;\r\n        ccs.minSlopeLimit = this._minSlopeLimit;\r\n        ccs.noFirstPerson = this._noFirstPerson;\r\n        ccs.stepOffset = this._stepOffset;\r\n        ccs.sound = this._stepSound;\r\n\r\n        return ccs;\r\n    }\r\n\r\n    public setSettings(ccs: CCSettings) {\r\n        this.setFaceForward(ccs.faceForward);\r\n        this.setMode(ccs.topDown ? 1 : 0);\r\n        this.setTurningOff(ccs.turningOff);\r\n        this.setCameraTarget(ccs.cameraTarget);\r\n        this.setCameraElasticity(ccs.cameraElastic);\r\n        this.setElasticiSteps(ccs.elasticSteps);\r\n        this.makeObstructionInvisible(ccs.makeInvisble);\r\n        this.setGravity(ccs.gravity);\r\n        this.enableKeyBoard(ccs.keyboard);\r\n        this.setSlopeLimit(ccs.minSlopeLimit, ccs.maxSlopeLimit);\r\n        this.setNoFirstPerson(ccs.noFirstPerson);\r\n        this.setStepOffset(ccs.stepOffset);\r\n        this.setSound(ccs.sound);\r\n\r\n    }\r\n\r\n    private _setAnim(anim: ActionData, animName?: string | AnimationGroup, rate?: number, loop?: boolean) {\r\n\r\n        //animation range need skeleton\r\n        if (!this._isAG && this._skeleton == null) return;\r\n\r\n        if (animName != null) {\r\n            if (this._isAG) {\r\n                if (!(animName instanceof AnimationGroup)) return;\r\n                anim.ag = <AnimationGroup>animName;\r\n                anim.exist = true;\r\n            } else {\r\n                if (this._skeleton.getAnimationRange(anim.name) != null) {\r\n                    anim.name = <string>animName;\r\n                    anim.exist = true;\r\n                } else {\r\n                    anim.exist = false;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (loop != null) anim.loop = loop;\r\n        if (rate != null) anim.rate = rate;\r\n    }\r\n\r\n    public enableBlending(n: number) {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let act = this._actionMap[key];\r\n                if (!(act instanceof ActionData)) continue;\r\n                if (act.exist) {\r\n                    let ar: AnimationGroup = act.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = true;\r\n                        ta.animation.blendingSpeed = n;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (this._skeleton !== null)\r\n                this._skeleton.enableBlending(n);\r\n        }\r\n    }\r\n\r\n    public disableBlending() {\r\n        if (this._isAG) {\r\n            let keys: string[] = Object.keys(this._actionMap);\r\n            for (let key of keys) {\r\n                let anim = this._actionMap[key];\r\n                if (!(anim instanceof ActionData)) continue;\r\n                if (anim.exist) {\r\n                    let ar: AnimationGroup = anim.ag;\r\n                    for (let ta of ar.targetedAnimations) {\r\n                        ta.animation.enableBlending = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //setters for animations\r\n    public setWalkAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walk, rangeName, rate, loop);\r\n    }\r\n    public setRunAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.run, rangeName, rate, loop);\r\n    }\r\n    public setWalkBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBack, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack);\r\n    }\r\n    public setWalkBackFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.walkBackFast, rangeName, rate, loop);\r\n    }\r\n    public setSlideBackAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.slideBack, rangeName, rate, loop);\r\n    }\r\n    public setIdleAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idle, rangeName, rate, loop);\r\n    }\r\n    public setTurnRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n    }\r\n    public setTurnRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnRightFast, rangeName, rate, loop);\r\n    }\r\n    public setTurnLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n    }\r\n    public setTurnLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.turnLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeRightAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRight, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n    }\r\n    public setStrafeRightFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeRightFast, rangeName, rate, loop);\r\n    }\r\n    public setStrafeLeftAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeft, rangeName, rate, loop);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n    public setStrafeLeftFastAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.strafeLeftFast, rangeName, rate, loop);\r\n    }\r\n    public setIdleJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.idleJump, rangeName, rate, loop);\r\n    }\r\n    public setRunJumpAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.runJump, rangeName, rate, loop);\r\n    }\r\n    public setFallAnim(rangeName: string | AnimationGroup, rate: number, loop: boolean) {\r\n        this._setAnim(this._actionMap.fall, rangeName, rate, loop);\r\n    }\r\n\r\n\r\n    _stepSound: Sound;\r\n    // setters for sound\r\n    public setSound(sound: Sound) {\r\n        if (sound == null) return;\r\n        this._stepSound = sound;\r\n        let ccActionNames: string[] = Object.keys(this._actionMap);\r\n        sound.loop = false;\r\n        for (let ccActionName of ccActionNames) {\r\n            let ccActData = this._actionMap[ccActionName];\r\n            //some keys could map to functions (like reset())\r\n            if (!(ccActData instanceof ActionData)) continue;\r\n            ccActData.sound = sound;\r\n            ccActData.sound.attachToMesh(this._avatar);\r\n        }\r\n        this._actionMap.idle.sound = null;\r\n        this._actionMap.fall.sound = null;\r\n        this._actionMap.slideBack.sound = null;\r\n    }\r\n\r\n\r\n    // setters for keys\r\n    public setWalkKey(key: string) {\r\n        this._actionMap.walk.key = key.toLowerCase();\r\n    }\r\n    public setWalkBackKey(key: string) {\r\n        this._actionMap.walkBack.key = key.toLowerCase();\r\n    }\r\n    public setTurnLeftKey(key: string) {\r\n        this._actionMap.turnLeft.key = key.toLowerCase();\r\n    }\r\n    public setTurnRightKey(key: string) {\r\n        this._actionMap.turnRight.key = key.toLowerCase();\r\n    }\r\n    public setStrafeLeftKey(key: string) {\r\n        this._actionMap.strafeLeft.key = key.toLowerCase();\r\n    }\r\n    public setStrafeRightKey(key: string) {\r\n        this._actionMap.strafeRight.key = key.toLowerCase();\r\n    }\r\n    public setJumpKey(key: string) {\r\n        this._actionMap.idleJump.key = key.toLowerCase();\r\n    }\r\n\r\n    public setCameraElasticity(b: boolean) {\r\n        this._cameraElastic = b;\r\n    }\r\n\r\n    public setElasticiSteps(n: number) {\r\n        this._elasticSteps = n;\r\n    }\r\n\r\n    public makeObstructionInvisible(b: boolean) {\r\n        this._makeInvisible = b;\r\n    }\r\n    public setCameraTarget(v: Vector3) {\r\n        this._cameraTarget.copyFrom(v);\r\n    }\r\n\r\n\r\n    /**\r\n     * user should call this whenever the user changes the camera checkCollision \r\n     * property\r\n     * \r\n     */\r\n    public cameraCollisionChanged() {\r\n        this._savedCameraCollision = this._camera.checkCollisions;\r\n    }\r\n    public setNoFirstPerson(b: boolean) {\r\n        this._noFirstPerson = b;\r\n    }\r\n\r\n    /**\r\n     * if av has the required anim (walk, run etc) then \r\n     * mark that anim as existing\r\n     * \r\n     * @param skel \r\n     */\r\n\r\n    private _checkAnimRanges(skel: Skeleton) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof ActionData)) continue;\r\n            if (skel != null) {\r\n                if (skel.getAnimationRange(anim.id) != null) {\r\n                    anim.name = anim.id;\r\n                    anim.exist = true;\r\n                    this._hasAnims = true;\r\n                }\r\n            } else {\r\n                anim.exist = false;\r\n            }\r\n        }\r\n        this._checkFastAnims();\r\n    }\r\n\r\n    /**\r\n     * if fast anims do not exist then use their slow counterpart as them but double the rate at which they play\r\n     */\r\n    private _checkFastAnims() {\r\n        this._copySlowAnims(this._actionMap.walkBackFast, this._actionMap.walkBack)\r\n        this._copySlowAnims(this._actionMap.turnRightFast, this._actionMap.turnRight);\r\n        this._copySlowAnims(this._actionMap.turnLeftFast, this._actionMap.turnLeft);\r\n        this._copySlowAnims(this._actionMap.strafeRightFast, this._actionMap.strafeRight);\r\n        this._copySlowAnims(this._actionMap.strafeLeftFast, this._actionMap.strafeLeft);\r\n    }\r\n\r\n    private _copySlowAnims(f: ActionData, s: ActionData) {\r\n        if (f.exist) return;\r\n        if (!s.exist) return;\r\n        f.exist = true;\r\n        f.ag = s.ag;\r\n        f.name = s.name;\r\n        f.rate = s.rate * 2;\r\n    }\r\n\r\n    /**\r\n     * Use this to make the  character controller suitable for a isometeric/top down games or  fps/third person game.\r\n     * 1 In isometric/top down games the camera direction has no bearing on avatar movement.\r\n     * 0 In fps/third person game rotating the camera around the avatar , rotates the avatar too.\r\n     * \r\n     * cannot switch mode to 0 if no camera avaiable.\r\n     */\r\n    private _mode = 0;\r\n    private _saveMode = 0;\r\n    public setMode(n: number) {\r\n        //cannot switch mode to 0 if no camera avaiable.\r\n        if (this._hasCam) {\r\n            this._mode = n;\r\n            this._saveMode = n;\r\n        } else {\r\n            this._mode = 1;\r\n            this._saveMode = 1;\r\n        }\r\n    }\r\n    public getMode() {\r\n        return this._mode;\r\n    }\r\n    /**\r\n     * Use this to set  turning off.\r\n     * When turining is off \r\n     * a) turn left or turn right keys result in avatar facing and moving left or right with respect to camera.\r\n     * b) walkback/runback key results in avatar facing back and walking/running towards camera.\r\n     * \r\n     * This setting has no effect when mode is 1.\r\n     * \r\n     * @param b \r\n     */\r\n    public setTurningOff(b: boolean) {\r\n        this._noRot = b;\r\n    }\r\n    public isTurningOff() {\r\n        return this._noRot;\r\n    }\r\n\r\n    /**\r\n        * checks if a have left hand , right hand issue.\r\n        * In other words if a mesh is a LHS mesh in RHS system or \r\n        * a RHS mesh in LHS system\r\n        * The X axis will be reversed in such cases.\r\n        * thus Cross product of X and Y should be inverse of Z.\r\n        * BABYLONJS GLB models are RHS and exhibit this behavior\r\n        * \r\n        */\r\n    private _isLHS_RHS = false;\r\n    private _signLHS_RHS = -1;\r\n    private _setRHS(mesh: TransformNode) {\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        const _localX = Vector3.FromArray(meshMatrix.m, 0);\r\n        const _localY = Vector3.FromArray(meshMatrix.m, 4);\r\n        const _localZ = Vector3.FromArray(meshMatrix.m, 8);\r\n        const actualZ = Vector3.Cross(_localX, _localY);\r\n        //same direction or opposite direction of Z\r\n        if (Vector3.Dot(actualZ, _localZ) < 0) {\r\n            this._isLHS_RHS = true;\r\n            this._signLHS_RHS = 1;\r\n        }\r\n        else {\r\n            this._isLHS_RHS = false;\r\n            this._signLHS_RHS = -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use setFaceForward(true|false) to indicate that the avatar's face  points forward (true) or backward (false).\r\n     * The avatar's face  points forward if its face is looking in positive local Z axis direction\r\n     */\r\n    private _ffSign: number;\r\n    private _rhsSign: number;\r\n    private _ff: boolean;\r\n    //in mode 0, av2cam is used to align avatar with camera , with camera always facing avatar's back\r\n    //note:camera alpha is measured anti-clockwise , avatar rotation is measured clockwise \r\n    private _av2cam;\r\n    public setFaceForward(b: boolean) {\r\n        this._ff = b;\r\n\r\n        this._rhsSign = this._scene.useRightHandedSystem ? -1 : 1;\r\n\r\n        if (!this._hasCam) {\r\n            this._av2cam = 0;\r\n            this._ffSign = 1;\r\n            return;\r\n        }\r\n\r\n        if (this._isLHS_RHS) {\r\n            this._av2cam = b ? Math.PI / 2 : 3 * Math.PI / 2;\r\n            this._ffSign = b ? 1 : -1;\r\n        } else {\r\n            this._av2cam = b ? 3 * Math.PI / 2 : Math.PI / 2;\r\n            this._ffSign = b ? -1 : 1;\r\n        }\r\n\r\n    }\r\n\r\n    public isFaceForward() {\r\n        return this._ff;\r\n    }\r\n\r\n    private checkAGs(agMap: {}) {\r\n        let keys: string[] = Object.keys(this._actionMap);\r\n        for (let key of keys) {\r\n            let anim = this._actionMap[key];\r\n            if (!(anim instanceof ActionData)) continue;\r\n            if (agMap[anim.name] != null) {\r\n                anim.ag = agMap[anim.name];\r\n                anim.exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // check if any of the mesh on the node tree is refrenced by any animation group\r\n    private _containsAG(node: Node, ags: AnimationGroup[], fromRoot: boolean) {\r\n        let r: Node;\r\n        let ns: Node[];\r\n\r\n        if (fromRoot) {\r\n            r = this._getRoot(node);\r\n            ns = r.getChildren((n) => { return (n instanceof TransformNode) }, false);\r\n        } else {\r\n            r = node;\r\n            ns = [r];\r\n        }\r\n\r\n        for (let ag of ags) {\r\n            let tas: TargetedAnimation[] = ag.targetedAnimations;\r\n            for (let ta of tas) {\r\n                if (ns.indexOf(ta.target) > -1) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //get the root of Node\r\n    private _getRoot(tn: Node): Node {\r\n        if (tn.parent == null) return tn;\r\n        return this._getRoot(tn.parent);\r\n    }\r\n\r\n    private _started: boolean = false;\r\n    public start() {\r\n        if (this._started) return;\r\n        this._started = true;\r\n        this._act.reset();\r\n        this._movFallTime = 0;\r\n        //first time we enter render loop, delta time is zero\r\n        this._idleFallTime = 0.001;\r\n        this._grounded = false;\r\n        this._updateTargetValue();\r\n        if (this._ekb) this._addkeylistener();\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    public stop() {\r\n        if (!this._started) return;\r\n        this._started = false;\r\n        this._scene.unregisterBeforeRender(this._renderer);\r\n        this._removekeylistener();\r\n        this._prevActData = null;\r\n    }\r\n\r\n    /**\r\n     * use pauseAnim to stop the charactere controller from playing\r\n     * any animation on the character\r\n     * use this when you want to play your animation instead\r\n     * see also resumeAnim()\r\n     */\r\n    private _stopAnim: boolean = false;\r\n    public pauseAnim() {\r\n        this._stopAnim = true;\r\n\r\n        if (this._prevActData != null && this._prevActData.exist) {\r\n            //stop current animation\r\n            if (this._isAG) {\r\n                this._prevActData.ag.stop();\r\n            } else {\r\n                //this._scene.stopAnimation(this._skeleton, this._prevActData.name);\r\n                this._scene.stopAnimation(this._skeleton);\r\n                //this._scene.stopAllAnimations();\r\n            }\r\n            //stop current sound\r\n            if (this._prevActData.sound != null) {\r\n                this._prevActData.sound.stop();\r\n            }\r\n            clearInterval(this._sndId);\r\n\r\n            this._scene.unregisterBeforeRender(this._renderer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * use resumeAnim to resume the character controller playing\r\n     * animations on the character.\r\n     * see also pauseAnim()\r\n     */\r\n    public resumeAnim() {\r\n        this._stopAnim = false;\r\n        this._prevActData = null;\r\n        this._scene.registerBeforeRender(this._renderer);\r\n    }\r\n\r\n    private _prevActData: ActionData = null;\r\n    private _avStartPos: Vector3 = Vector3.Zero();\r\n    private _pickStartY: number = 0;\r\n    private _grounded: boolean = false;\r\n    //distance by which AV would move down if in freefall\r\n    private _freeFallDist: number = 0;\r\n\r\n    //how many minimum contiguos frames should the AV have been in free fall\r\n    //before we assume AV is in big freefall.\r\n    //we will use this to remove animation flicker during move down a slope (fall, move, fall move etc)\r\n    //TODO: base this on slope - large slope large count\r\n    private _fallFrameCountMin: number = 20;\r\n    private _fallFrameCount: number = 0;\r\n\r\n    private _inFreeFall: boolean = false;\r\n    private _wasWalking: boolean = false;\r\n    private _wasRunning: boolean = false;\r\n    private _moveVector: Vector3;\r\n\r\n    //used only in mode 1\r\n    //value 1 or -1 , -1 if avatar is facing camera\r\n    //private _notFacingCamera = 1;\r\n\r\n    private _isAvFacingCamera(): number {\r\n        if (!this._hasCam) return 1;\r\n        if (Vector3.Dot(this._avatar.forward, this._avatar.position.subtract(this._camera.position)) < 0) return 1\r\n        else return -1;\r\n    }\r\n\r\n    private _moveAVandCamera() {\r\n        this._avStartPos.copyFrom(this._avatar.position);\r\n        let actData: ActionData = null;\r\n        const dt: number = this._scene.getEngine().getDeltaTime() / 1000;\r\n\r\n        if (this._act._jump && !this._inFreeFall) {\r\n            this._vMoveTot = 0;\r\n            this._pauseCam = false;\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            actData = this._doJump(dt);\r\n        } else if (this.anyMovement() || this._inFreeFall) {\r\n            this._grounded = false;\r\n            this._idleFallTime = 0;\r\n            actData = this._doMove(dt);\r\n        } else if (!this._inFreeFall) {\r\n            actData = this._doIdle(dt);\r\n        }\r\n\r\n        if (!this._stopAnim && this._hasAnims && actData != null) {\r\n            // console.log(\"anim: \" + actData.name);\r\n            if (this._prevActData !== actData) {\r\n                if (actData.exist) {\r\n\r\n                    //animation frame counts\r\n                    let c: number;\r\n                    let fps: number = 30;\r\n\r\n                    if (this._isAG) {\r\n                        if (this._prevActData != null && this._prevActData.exist) this._prevActData.ag.stop();\r\n                        actData.ag.start(actData.loop, actData.rate);\r\n                        fps = actData.ag.targetedAnimations[0].animation.framePerSecond;\r\n                        c = (actData.ag.to - actData.ag.from);\r\n                    } else {\r\n                        let a: Animatable = this._skeleton.beginAnimation(actData.name, actData.loop, actData.rate);\r\n                        fps = a.getAnimations()[0].animation.framePerSecond;\r\n                        c = this._skeleton.getAnimationRange(actData.name).to - this._skeleton.getAnimationRange(actData.name).from;\r\n                    }\r\n\r\n                    //SOUND\r\n                    //TODO do sound as animationevent.\r\n                    if (this._prevActData != null && this._prevActData.sound != null) {\r\n                        this._prevActData.sound.stop();\r\n                    }\r\n                    clearInterval(this._sndId);\r\n                    if (actData.sound != null) {\r\n                        actData.sound.play();\r\n                        //play sound twice during the animation\r\n                        this._sndId = setInterval(() => { actData.sound.play(); }, c * 1000 / (fps * Math.abs(actData.rate) * 2));\r\n                    }\r\n                }\r\n                this._prevActData = actData;\r\n            }\r\n        }\r\n        this._updateTargetValue();\r\n        return;\r\n    }\r\n\r\n    private _soundLoopTime = 700;\r\n    private _sndId = null;\r\n\r\n    //verical position of AV when it is about to start a jump\r\n    private _jumpStartPosY: number = 0;\r\n    //for how long the AV has been in the jump\r\n    private _jumpTime: number = 0;\r\n    private _doJump(dt: number): ActionData {\r\n\r\n        let actData: ActionData = null;\r\n        actData = this._actionMap.runJump;\r\n        if (this._jumpTime === 0) {\r\n            this._jumpStartPosY = this._avatar.position.y;\r\n        }\r\n\r\n        this._jumpTime = this._jumpTime + dt;\r\n\r\n        let forwardDist: number = 0;\r\n        let jumpDist: number = 0;\r\n        let disp: Vector3;\r\n\r\n        // if (this._hasCam && this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        if (this._wasRunning || this._wasWalking) {\r\n            if (this._wasRunning) {\r\n                forwardDist = this._actionMap.run.speed * dt;\r\n            } else if (this._wasWalking) {\r\n                forwardDist = this._actionMap.walk.speed * dt;\r\n            }\r\n            //find out in which horizontal direction the AV was moving when it started the jump\r\n            disp = this._moveVector.clone();\r\n            disp.y = 0;\r\n            disp = disp.normalize();\r\n            disp.scaleToRef(forwardDist, disp);\r\n            jumpDist = this._calcJumpDist(this._actionMap.runJump.speed, dt);\r\n            disp.y = jumpDist;\r\n        } else {\r\n            jumpDist = this._calcJumpDist(this._actionMap.idleJump.speed, dt);\r\n            disp = new Vector3(0, jumpDist, 0);\r\n            actData = this._actionMap.idleJump;\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y/2;\r\n        }\r\n        //moveWithCollision only seems to happen if length of displacment is atleast 0.001\r\n        this._avatar.moveWithCollisions(disp);\r\n        if (jumpDist < 0) {\r\n            //this.avatar.ellipsoid.y=this._ellipsoid.y;\r\n            //check if going up a slope or back on flat ground \r\n            if ((this._avatar.position.y > this._avStartPos.y) || ((this._avatar.position.y === this._avStartPos.y) && (disp.length() > 0.001))) {\r\n                this._endJump();\r\n            } else if (this._avatar.position.y < this._jumpStartPosY) {\r\n                //the avatar is below the point from where it started the jump\r\n                //so it is either in free fall or is sliding along a downward slope\r\n                //\r\n                //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n                //else it is on a slope\r\n                const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n                if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                    //AV is on slope\r\n                    //Should AV continue to slide or stop?\r\n                    //if slope is less steeper than acceptable then stop else slide\r\n                    let _ng = this._isNearGround(actDisp);\r\n                    if (_ng.slope <= this._sl1) {\r\n                        this._endJump();\r\n                    }\r\n                } else {\r\n                    actData = this._actionMap.fall;\r\n                }\r\n            }\r\n        }\r\n        return actData;\r\n    }\r\n\r\n    private _calcJumpDist(speed: number, dt: number): number {\r\n        //up velocity at the begining of the last frame (v=u+at)\r\n        let js: number = speed - this._gravity * this._jumpTime;\r\n        //distance travelled up since last frame to this frame (s=ut+1/2*at^2)\r\n        let jumpDist: number = js * dt - 0.5 * this._gravity * dt * dt;\r\n        return jumpDist;\r\n    }\r\n\r\n    /**\r\n     * does cleanup at the end of a jump\r\n     */\r\n    private _endJump() {\r\n        this._act._jump = false;\r\n        this._jumpTime = 0;\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n    }\r\n\r\n    /**\r\n     * checks if two vectors v1 and v2 are equal within a precision of p\r\n     */\r\n    private _areVectorsEqual(v1: Vector3, v2: Vector3, p: number) {\r\n        return ((Math.abs(v1.x - v2.x) < p) && (Math.abs(v1.y - v2.y) < p) && (Math.abs(v1.z - v2.z) < p));\r\n    }\r\n\r\n    /*\r\n     * returns the slope (in radians) of a vector in the vertical plane\r\n     */\r\n    private _verticalSlope(v: Vector3): number {\r\n        return Math.atan(Math.abs(v.y / Math.sqrt(v.x * v.x + v.z * v.z)));\r\n    }\r\n\r\n    //for how long has the av been falling while moving\r\n    private _movFallTime: number = 0;\r\n    private _sign = 1;\r\n    private _isTurning = false;\r\n    private _noRot = false;\r\n    private _steps = true;\r\n    private _stepHigh:boolean = false;\r\n    private _doMove(dt: number): ActionData {\r\n        // console.log(\"doMove\");\r\n\r\n        //initial down velocity (v=u+at)\r\n        const u: number =  this._gravity * this._movFallTime ;\r\n\r\n        //calculate the distance by which av should move down since last frame\r\n        //s=ut+att/2\r\n        this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n\r\n        this._movFallTime = this._movFallTime + dt;\r\n\r\n        let moving: boolean = false;\r\n        let actdata: ActionData = null;\r\n\r\n        if (this._inFreeFall) {\r\n            this._moveVector.y = -this._freeFallDist;\r\n            moving = true;\r\n        }\r\n\r\n\r\n        //rotate avatar with respect to camera direction. \r\n        this._rotateAV2C();\r\n\r\n        //rotate the avatar in case player is trying to rotate the avatar. rotate the camera too if camera turning is on\r\n        actdata = this._rotateAVnC(actdata, moving, dt);\r\n\r\n        //now that avatar is rotated properly, construct the vector to move the avatar \r\n        //donot move the avatar if avatar is in freefall\r\n\r\n        if (!this._inFreeFall) {\r\n            this._wasWalking = false;\r\n            this._wasRunning = false;\r\n\r\n            let sign: number;\r\n            let horizDist: number = 0;\r\n            switch (true) {\r\n                case (this._act._stepLeft):\r\n                    // console.log(\"step left\");\r\n                    sign = this._signLHS_RHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeLeft.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeLeftFast.speed * dt;\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._stepRight):\r\n                    // console.log(\"step right\");\r\n                    sign = -this._signLHS_RHS * this._isAvFacingCamera();\r\n                    horizDist = this._actionMap.strafeRight.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.strafeRightFast.speed * dt;\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeftFast : this._actionMap.strafeRightFast;\r\n                    } else {\r\n                        actdata = (-this._ffSign * sign > 0) ? this._actionMap.strafeLeft : this._actionMap.strafeRight;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(sign * horizDist, -this._freeFallDist, 0);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walk || (this._noRot && this._mode == 0)):\r\n                    // console.log(\"walk\");\r\n                    if (this._act._speedMod) {\r\n                        this._wasRunning = true;\r\n                        horizDist = this._actionMap.run.speed * dt;\r\n                        actdata = this._actionMap.run;\r\n                    } else {\r\n                        this._wasWalking = true;\r\n                        horizDist = this._actionMap.walk.speed * dt;\r\n                        actdata = this._actionMap.walk;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n                case (this._act._walkback):\r\n                    // console.log(\"walk back\");\r\n                    horizDist = this._actionMap.walkBack.speed * dt;\r\n                    if (this._act._speedMod) {\r\n                        horizDist = this._actionMap.walkBackFast.speed * dt;\r\n                        actdata = this._actionMap.walkBackFast;\r\n                    } else {\r\n                        actdata = this._actionMap.walkBack;\r\n                    }\r\n                    this._moveVector = this._avatar.calcMovePOV(0, -this._freeFallDist, -this._ffSign * horizDist);\r\n                    moving = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // move the avatar\r\n        if (moving) {\r\n            if (this._moveVector.length() > 0.001) {\r\n                //console.log(\"moving\", this._moveVector);\r\n                this._avatar.moveWithCollisions(this._moveVector);\r\n\r\n                let actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n\r\n                const _ng = this._isNearGround(actDisp);\r\n\r\n                let dy = this._avatar.position.y - this._avStartPos.y;\r\n                if (Math.abs(dy) > 0.01) {\r\n                    console.log(dy);\r\n                }\r\n\r\n                //walking up a step or a  slope\r\n                if (this._avatar.position.y - this._avStartPos.y > 0.01) {\r\n                //if (this._avatar.position.y > this._avStartPos.y) {\r\n                    //if AV is going up even though slope is 0 then that means AV is trying to climb steps\r\n                    //The elliptical shape of ellipsoid allows this.\r\n                    if (_ng.slope == 0) {\r\n                        //if user has specified step offset then prevent AV from going beyond that\r\n                        //otherwise allow whatever the ellisoid allows\r\n                        if (this._stepOffset > 0) {\r\n                            if (this._vMoveTot == 0) {\r\n                                //if AV just started climbing step, note down the position\r\n                                this._vMovStartPos.copyFrom(this._avStartPos);\r\n\r\n                                //The pick ray being in front, will pick a step and \r\n                                //thus can be used to calc the step height\r\n                                let stepHeight = _ng.y - this._vMovStartPos.y;\r\n\r\n                                //if the step height is more than that allowed\r\n                                if (stepHeight > this._stepOffset) {\r\n                                    this._stepHigh = true;\r\n                                    //move av back to its position at begining of steps\r\n                                    // this._avatar.position.copyFrom(this._vMovStartPos);\r\n                                    // this._pauseCam = true;\r\n                                }else{\r\n                                    this._stepHigh = false;\r\n                                }\r\n                            }\r\n                          \r\n\r\n                            //if the av is trying to climb step at an angle then the pick might miss the step\r\n                            //in such case let the av move up but keep track of how much it has moved up\r\n                            this._vMoveTot = this._avatar.position.y - this._vMovStartPos.y;\r\n\r\n                            //if the total amount by which the AV has moved up exceeds the allowable limit then\r\n                            //move av back to its position at begining of steps\r\n                            //(this doesnot seem to work very reliably)\r\n                            if (this._stepHigh) {\r\n                                //move av back to its position at begining of steps\r\n                                this._avatar.position.copyFrom(this._vMovStartPos);\r\n                            }\r\n                            // else if (this._vMoveTot > this._stepOffset) {\r\n                            //     this._avatar.position.copyFrom(this._vMovStartPos);\r\n                            //     this._pauseCam=true;\r\n                            //     this._vMoveTot = 0\r\n                            // }   \r\n                        }\r\n                    } else {\r\n                        //looks like the avatar is going up a slope\r\n                        this._vMoveTot = 0;\r\n                        this._pauseCam=false;\r\n                        const _slp = _ng.slope;\r\n\r\n                        //if slope is less than the higher slope limit then continue moving up\r\n                        //if slope is greater than the higher slope limit then stop moving up\r\n                        //\r\n                        //But sometimes even if the the slope is greater than the higher slope limit \r\n                        //we may want avatar to continue moving up the slope.\r\n                        //Remember that the the ray is in front of the avatar (when the avatar is facing the slope).\r\n                        //Thus the slope read, is not the slope of the ground under the avatar but of ground in front of the avatar.\r\n                        //Now the ground in front can suddenly start sloping down more than allowable limit.\r\n                        //In that case the avatar should not stop but continue moving forward.\r\n                        //To identify this use case we need to check if the current pickpoint is below the previous pickpoint.\r\n                        //Normally if we are going up the slope then the current pickpoint\r\n                        //should always be above the previous pickpoint.\r\n                        //If this is not the case then we have identifed this use case of a downward slope ahead.\r\n                        //Note: the slope does not tell us if it is a upward slope or a downward slope\r\n\r\n                        if (_slp >= this._sl2 && _ng.y > this._pickStartY) {\r\n                            //move av back to old position\r\n                            this._avatar.position.copyFrom(this._avStartPos);\r\n                            this._endFreeFall();\r\n                            this._pickStartY = 0;\r\n                        } else {\r\n                            //keep moving up the slope\r\n                            this._pickStartY = _ng.y;\r\n                            if (_slp > this._sl1) {\r\n                                //av is on a steep slope , continue increasing the moveFallTIme to deaccelerate it\r\n                                this._fallFrameCount = 0;\r\n                                this._inFreeFall = false;\r\n                            } else {\r\n                                //continue walking\r\n                                this._endFreeFall();\r\n                            }\r\n                        }\r\n                    }\r\n                   \r\n                } else \r\n                    // if (this._avStartPos.y - this._avatar.position.y > 0.01 ) {\r\n                    if ( this._avatar.position.y < this._avStartPos.y ) {\r\n                    this._pauseCam = false;\r\n                    //av is going down a slope or is in free fall\r\n                    this._vMoveTot = 0;\r\n                    const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n\r\n                    //if the AV falls by an amount equal to the free fall distance calculated then it is in freefall\r\n                    //Now the AV could be going down a slope but still be seen as if it is in a freefall.\r\n                    //This could happen if the AV is going down a steep fall. In such cases the AV move forward, \r\n                    // goes in freefall,hits the slope,goes in freefall again and so on\r\n                    //To make sure this is not the case check the pickray does not hit the ground or if it does then \r\n                    // the pickpoint is atleast 1 unit(?) below the avatar's position\r\n                    //if (this._areVectorsEqual(actDisp, this._moveVector, 0.001) &&  (!_ng.hit || (_ng.hit && this._avatar.position.y - _ng.y > 1))) {\r\n                    if (this._areVectorsEqual(actDisp, this._moveVector, 0.001) &&  !_ng.hit) {\r\n                        //AV is in freefall\r\n\r\n                        this._pauseCam = false;\r\n                        this._inFreeFall = true;\r\n                        \r\n                        //AV could be running down a slope which mean freefall,run,freefall run ...\r\n                        //to remove anim flicker, check if AV has been falling down continously for last few consecutive frames\r\n                        //before changing to free fall animation\r\n                        // this._fallFrameCount++;\r\n                        // if (this._fallFrameCount > this._fallFrameCountMin) {\r\n                            actdata = this._actionMap.fall;\r\n                        // }\r\n                    \r\n                  \r\n                    }else {\r\n                          //if (_ng.y >= this._avatar.position.y) {\r\n                        //AV is on ground and thus on slope\r\n                        //\r\n                        //Should AV continue to slide or walk?\r\n                        //if slope is less steeper than acceptable then walk else slide\r\n                        //if (this._verticalSlope(actDisp) <= this._sl1) {\r\n                            if (_ng.slope <= this._sl1) {\r\n                               // this._endFreeFall();\r\n                               this._fallFrameCount = 0;\r\n                                this._inFreeFall = false;\r\n                            } else {\r\n                                //av is on a steep slope , keep the moveFallTIme non zero to continue deaccelerate it vertically\r\n                                this._fallFrameCount = 0;\r\n                                this._inFreeFall = false;\r\n                            }\r\n                       \r\n                    }\r\n                } else {\r\n                    //AV is walking on a flat surface\r\n                    this._pauseCam = false;\r\n                    this._vMoveTot = 0;\r\n                    //this._endFreeFall();\r\n                    this._fallFrameCount = 0;\r\n                    this._inFreeFall = false;\r\n                }\r\n            }\r\n        }\r\n        return actdata;\r\n    }\r\n\r\n\r\n\r\n    //check if any collidable mesh is just below the avatar's ellipsoid\r\n    private _isNearGround(actDisp: Vector3): { \"name\": string, \"ground\": boolean, \"slope\": number,\"y\":number,\"hit\":boolean } {\r\n\r\n        let upDist = this._avatar.position.y - this._avStartPos.y;\r\n        // console.log(\"upDist\", upDist);\r\n        let up:boolean = true;\r\n        if (Math.abs(upDist) < 0.006) { \r\n            up = true;\r\n        }else{\r\n            up = (upDist > 0.01 ) ? true : false;\r\n        }\r\n        let fwd: boolean;\r\n        actDisp.y = 0;\r\n        if (actDisp.x == 0 && actDisp.z == 0) {\r\n            fwd = true;\r\n        } else {\r\n            let cosTheta = Vector3.Dot(this._avatar.forward, actDisp.normalize());\r\n            fwd = (cosTheta >= 0) ? true : false;\r\n        }\r\n        let fact = (up && fwd) || (!up && !fwd) ? 1 : -1;\r\n\r\n        //SAT DEBUG\r\n        // fact=1;\r\n\r\n        // send the pick ray vertically down starting from a pont which is\r\n        // a) in the middle of the ellipsoid  and\r\n        // b) either front or back of the avatar\r\n        // if AV is moving forward and up (in otherwords facing the slope) then ray in front\r\n        // if AV is moving backward and down (in otherwords facing the slope) then ray in front\r\n        // if AV is moving forward and down (in otherwords facing away from the slope) then ray in back\r\n        // if AV is moving backward and  up (in otherwords facing away from the slope) then ray in back\r\n        // This way the ray is targetting a point on the ground which is slightly above the avatar feet thus \r\n        // ensuring that the ray will always hit the ground.\r\n        // The length of the ray is such that it atleast reaches the bottom of the avator.\r\n\r\n        this._avatar.forward.scaleToRef(this._avatar.ellipsoid.x * fact, this._ray.origin);\r\n        this._ray.origin.addToRef(this._avatar.position, this._ray.origin);\r\n        this._ray.origin.addToRef(this._avatar.ellipsoidOffset, this._ray.origin);\r\n        //this._avatar.position.addToRef(this._avatar.ellipsoidOffset, this._ray.origin);\r\n        //this._ray.origin.y = this._ray.origin.y - this._avatar.ellipsoid.y;\r\n        //from the bottom of ellipsoid go down 1/4 the ellipsoid height to check for any mesh\r\n        //this._ray.length = this._avatar.ellipsoid.y + this._stepOffset;\r\n        this._ray.length = this._avatar.ellipsoid.y *2;\r\n        //direction is towards the bottom\r\n        this._ray.direction = this._down;\r\n\r\n        //draw pick ray\r\n        if (this._ellipsoid !=null) {\r\n            this._drawLines(this._ray.origin, this._ray.origin.add(new Vector3(0, -this._ray.length, 0)));\r\n        }\r\n\r\n        \r\n        //handle case were pick is with a child of avatar, avatar atatchment. etc\r\n        //check if any collidable mesh is there just below the avatar's ellipsoid\r\n        const pi: PickingInfo = this._scene.pickWithRay(this._ray, (mesh) => {\r\n            if (this._avChildren.includes(mesh)) return false;\r\n            if (mesh.checkCollisions) return true;\r\n            return false;\r\n        });\r\n\r\n        if (pi != null && pi.hit) {\r\n            let n: Vector3 = pi.getNormal(true, true);\r\n            let slope: number = Math.PI / 2 - Math.asin(Math.abs(n.y));\r\n            return { \"name\": pi.pickedMesh.name, \"ground\": true, \"slope\": slope, \"y\":pi.pickedPoint.y, \"hit\":true };\r\n        }\r\n        else return { \"name\": \"\", \"ground\": false, \"slope\": 0, \"y\":0, \"hit\":false };\r\n\r\n    }\r\n\r\n\r\n    //check if any collidable mesh is just below the avatar's ellipsoid\r\n    private _isNearGround_old(): { \"name\": string, \"ground\": boolean, \"slope\": number } {\r\n        //start the ray from the bottom of avatar's ellipsod\r\n        //ellipsoid center = avatar position + ellipsoid offset\r\n        //ellipsoid bottom = ellipsoid center - ellipsoid height \r\n        this._avatar.position.addToRef(this._avatar.ellipsoidOffset, this._ray.origin);\r\n        this._ray.origin.y = this._ray.origin.y - this._avatar.ellipsoid.y;\r\n        //from the bottom of ellipsoid go down 1/4 the ellipsoid height to check for any mesh\r\n        this._ray.length = this._avatar.ellipsoid.y / 2;\r\n        //direction is towards the bottom\r\n        this._ray.direction = this._down;\r\n\r\n\r\n\r\n        //TODO \r\n        //handle case were pick is with a child of avatar, avatar atatchment. etc\r\n        //check if any collidable mesh is there just below the avatar's ellipsoid\r\n        const pis: PickingInfo[] = this._scene.multiPickWithRay(this._ray, (mesh) => {\r\n            if (mesh == this._avatar) return false;\r\n            if (mesh.checkCollisions) return true\r\n            else return false;\r\n        });\r\n\r\n        if (pis.length > 0) {\r\n            let pi: PickingInfo = pis[0];\r\n\r\n            let n: Vector3 = pi.getNormal(true, true);\r\n            let slope: number = Math.PI / 2 - Math.asin(Math.abs(n.y));\r\n\r\n            return { \"name\": pi.pickedMesh.name, \"ground\": true, \"slope\": slope };\r\n        }\r\n        else return { \"name\": \"\", \"ground\": false, \"slope\": 0 };\r\n\r\n    }\r\n\r\n\r\n    //for debugging purpose draws the rayline use to detect slope or steps\r\n    _rayLine: LinesMesh = null;\r\n    _lineOptions:any = {};\r\n    private _drawLines(pt1: Vector3, pt2: Vector3) {\r\n        if (this._rayLine == null){\r\n            const myPoints = [pt1, pt2];\r\n            this._lineOptions = {\r\n                points: myPoints,\r\n                updatable: true\r\n            }\r\n            this._rayLine = MeshBuilder.CreateLines(\"lines\", this._lineOptions );\r\n        }else {\r\n            this._lineOptions.points[0]=pt1;\r\n            this._lineOptions.points[1]=pt2;\r\n            this._lineOptions.instance = this._rayLine;\r\n            this._rayLine = MeshBuilder.CreateLines(\"lines\", this._lineOptions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * rotate avatar with respect to camera direction. \r\n     */\r\n    private _rotateAV2C() {\r\n        if (this._hasCam)\r\n            if (this._mode != 1) {\r\n                let ca = (this._hasCam) ? (this._av2cam - this._camera.alpha) : 0;\r\n                if (this._noRot) {\r\n                    switch (true) {\r\n                        case (this._act._walk && this._act._turnRight):\r\n                            this._avatar.rotation.y = ca + this._rhsSign * Math.PI / 4;\r\n                            break;\r\n                        case (this._act._walk && this._act._turnLeft):\r\n                            this._avatar.rotation.y = ca - this._rhsSign * Math.PI / 4;\r\n                            break;\r\n                        case (this._act._walkback && this._act._turnRight):\r\n                            this._avatar.rotation.y = ca + this._rhsSign * 3 * Math.PI / 4;\r\n                            break;\r\n                        case (this._act._walkback && this._act._turnLeft):\r\n                            this._avatar.rotation.y = ca - this._rhsSign * 3 * Math.PI / 4;\r\n                            break;\r\n                        case (this._act._walk):\r\n                            this._avatar.rotation.y = ca;\r\n                            break;\r\n                        case (this._act._walkback):\r\n                            this._avatar.rotation.y = ca + Math.PI;\r\n                            break;\r\n                        case (this._act._turnRight):\r\n                            this._avatar.rotation.y = ca + this._rhsSign * Math.PI / 2;\r\n                            break;\r\n                        case (this._act._turnLeft):\r\n                            this._avatar.rotation.y = ca - this._rhsSign * Math.PI / 2;\r\n                            break;\r\n                    }\r\n                } else {\r\n                    if (this._hasCam)\r\n                        this._avatar.rotation.y = ca;\r\n                }\r\n            }\r\n    }\r\n\r\n    //rotate the avatar in case player is trying to rotate the avatar. rotate the camera too if camera turning is on\r\n    private _rotateAVnC(anim: ActionData, moving: boolean, dt: number): ActionData {\r\n        if (!(this._noRot && this._mode == 0) && (!this._act._stepLeft && !this._act._stepRight) && (this._act._turnLeft || this._act._turnRight)) {\r\n            let turnAngle = this._actionMap.turnLeft.speed * dt;\r\n            if (this._act._speedMod) {\r\n                turnAngle = 2 * turnAngle;\r\n            }\r\n            let a;\r\n            if (this._mode == 1) {\r\n                // while turining, the avatar could start facing away from camera and end up facing camera.\r\n                // we should not switch turning direction during this transition\r\n                if (!this._isTurning) {\r\n                    // if (this._act.name != this._act.prevName) {\r\n                    // this._act.prevName = this._act.name;\r\n                    this._sign = -this._ffSign * this._isAvFacingCamera();\r\n                    if (this._isLHS_RHS) this._sign = - this._sign;\r\n                    this._isTurning = true;\r\n                }\r\n                a = this._sign;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walk) { }\r\n                    else if (this._act._walkback) a = -this._sign;\r\n                    else {\r\n                        anim = (this._sign > 0) ? this._actionMap.turnRight : this._actionMap.turnLeft;\r\n                    }\r\n                } else {\r\n                    if (this._act._walk) a = -this._sign;\r\n                    else if (this._act._walkback) { }\r\n                    else {\r\n                        a = -this._sign;\r\n                        anim = (this._sign > 0) ? this._actionMap.turnLeft : this._actionMap.turnRight;\r\n                    }\r\n                }\r\n            } else {\r\n                a = 1;\r\n                if (this._act._turnLeft) {\r\n                    if (this._act._walkback) a = -1;\r\n                    if (!moving) anim = this._actionMap.turnLeft;\r\n                } else {\r\n                    if (this._act._walk) a = -1;\r\n                    if (!moving) { a = -1; anim = this._actionMap.turnRight; }\r\n                }\r\n                if (this._hasCam)\r\n                    this._camera.alpha = this._camera.alpha + this._rhsSign * turnAngle * a;\r\n            }\r\n\r\n            this._avatar.rotation.y = this._avatar.rotation.y + turnAngle * a;\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _endFreeFall(): void {\r\n        this._movFallTime = 0;\r\n        this._fallFrameCount = 0;\r\n        this._inFreeFall = false;\r\n    }\r\n\r\n    //for how long has the av been falling while idle (not moving)\r\n    private _idleFallTime: number = 0;\r\n    private _doIdle(dt: number): ActionData {\r\n        // console.log(\"idling\");\r\n        if (this._grounded) {\r\n            return this._actionMap.idle;\r\n        }\r\n        this._wasWalking = false;\r\n        this._wasRunning = false;\r\n        this._movFallTime = 0;\r\n        let anim: ActionData = this._actionMap.idle;\r\n        this._fallFrameCount = 0;\r\n\r\n\r\n        if (dt === 0) {\r\n            this._freeFallDist = 5;\r\n        } else {\r\n            const u: number = this._idleFallTime * this._gravity\r\n            this._freeFallDist = u * dt + this._gravity * dt * dt / 2;\r\n            this._idleFallTime = this._idleFallTime + dt;\r\n        }\r\n        //if displacement is less than 0.01(? need to verify further) then \r\n        //moveWithDisplacement down against a surface seems to push the AV up by a small amount!!\r\n        if (this._freeFallDist < 0.01) return anim;\r\n        const disp: Vector3 = new Vector3(0, -this._freeFallDist, 0);\r\n        // if (this._hasCam && this._mode != 1 && !this._noRot) this._avatar.rotation.y = this._av2cam - this._camera.alpha;\r\n        this._avatar.moveWithCollisions(disp);\r\n        if ((this._avatar.position.y > this._avStartPos.y) || (this._avatar.position.y === this._avStartPos.y)) {\r\n            //                this.grounded = true;\r\n            //                this.idleFallTime = 0;\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            let ng = this._isNearGround(actDisp);\r\n            //if (this._verticalSlope(actDisp) <= this._sl1) {\r\n            if (ng.slope <= this._sl1) {\r\n                this._groundIt();\r\n                this._avatar.position.copyFrom(this._avStartPos);\r\n            } else {\r\n                this._unGroundIt();\r\n                anim = this._actionMap.slideBack;\r\n            }\r\n\r\n            //this._groundIt();\r\n        } else if (this._avatar.position.y < this._avStartPos.y) {\r\n            //AV is going down. \r\n            //AV is either in free fall or is sliding along a downward slope\r\n            //\r\n            //if the actual displacemnt is same as the desired displacement then AV is in freefall\r\n            //else it is on a slope\r\n            const actDisp: Vector3 = this._avatar.position.subtract(this._avStartPos);\r\n            if (!(this._areVectorsEqual(actDisp, disp, 0.001))) {\r\n                //AV is on slope\r\n                //Should AV continue to slide or stop?\r\n                //if slope is less steeper than accebtable then stop else slide\r\n                let ng = this._isNearGround(actDisp);\r\n                if (ng.slope <= this._sl1) {\r\n                    this._groundIt();\r\n                    this._avatar.position.copyFrom(this._avStartPos);\r\n                } else {\r\n                    this._unGroundIt();\r\n                    anim = this._actionMap.slideBack;\r\n                }\r\n            } else {\r\n                anim = this._actionMap.fall;\r\n            }\r\n        }\r\n        return anim;\r\n    }\r\n\r\n    private _groundFrameCount = 0;\r\n    private _groundFrameMax = 10;\r\n    /**\r\n     * donot ground immediately\r\n     * wait few more frames\r\n     */\r\n    private _groundIt(): void {\r\n        this._groundFrameCount++;\r\n        if (this._groundFrameCount > this._groundFrameMax) {\r\n            this._grounded = true;\r\n            this._idleFallTime = 0;\r\n        }\r\n    }\r\n    private _unGroundIt() {\r\n        this._grounded = false;\r\n        this._groundFrameCount = 0;\r\n    }\r\n\r\n    private _savedCameraCollision: boolean = true;\r\n    private _inFP = false;\r\n    private _updateTargetValue() {\r\n        if (!this._hasCam) return;\r\n        //donot move camera if av is trying to clinb steps\r\n        //if (this._vMoveTot == 0)\r\n        if (!this._pauseCam) {\r\n            this._avatar.position.addToRef(this._cameraTarget, this._camera.target);\r\n        }else{ \r\n            this._vMovStartPos.addToRef(this._cameraTarget, this._camera.target);\r\n        }\r\n\r\n        if (this._camera.radius > this._camera.lowerRadiusLimit) { if (this._cameraElastic || this._makeInvisible) this._handleObstruction(); }\r\n\r\n        //if user so desire, make the AV invisible if camera comes close to it\r\n        if (this._camera.radius <= this._camera.lowerRadiusLimit) {\r\n            if (!this._noFirstPerson && !this._inFP) {\r\n                this._makeMeshInvisible(this._avatar);\r\n                this._camera.checkCollisions = false;\r\n                this._saveMode = this._mode;\r\n                this._mode = 0;\r\n                this._inFP = true;\r\n            }\r\n        } else {\r\n            if (this._inFP) {\r\n                this._inFP = false;\r\n                this._mode = this._saveMode;\r\n                this._restoreVisiblity(this._avatar);\r\n                this._camera.checkCollisions = this._savedCameraCollision;\r\n            }\r\n        }\r\n    }\r\n\r\n    // make mesh and all its children invisible\r\n    // store their current visibility state so that we can restore them later on\r\n    private _makeMeshInvisible(mesh: Mesh) {\r\n\r\n        this._visiblityMap.set(mesh, mesh.visibility);\r\n        mesh.visibility = 0;\r\n\r\n        mesh.getChildMeshes(false, (n) => {\r\n            if (n instanceof Mesh) {\r\n                this._visiblityMap.set(n, n.visibility);\r\n                n.visibility = 0;\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n\r\n    private _visiblityMap: Map<Mesh, int> = new Map();\r\n\r\n    //restore mesh visibility to previous state\r\n    private _restoreVisiblity(mesh: Mesh) {\r\n        mesh.visibility = this._visiblityMap.get(mesh);\r\n        mesh.getChildMeshes(false, (n) => {\r\n            if (n instanceof Mesh) n.visibility = this._visiblityMap.get(n);\r\n            return false;\r\n        });\r\n    }\r\n\r\n    private _ray: Ray = new Ray(Vector3.Zero(), Vector3.One(), 1);\r\n    private _rayDir: Vector3 = Vector3.Zero();\r\n    //camera seems to get stuck into things\r\n    //should move camera away from things by a value of cameraSkin\r\n    private _cameraSkin: number = 0.5;\r\n    private _prevPickedMeshes: AbstractMesh[];\r\n    private _pickedMeshes: AbstractMesh[] = new Array();;\r\n    private _makeInvisible = false;\r\n    private _elasticSteps = 50;\r\n    private _alreadyInvisible: AbstractMesh[];\r\n\r\n    /**\r\n     * The following method handles the use case wherein some mesh\r\n     * comes between the avatar and the camera thus obstructing the view\r\n     * of the avatar.\r\n     * Two ways this can be handled\r\n     * a) make the obstructing  mesh invisible\r\n     *   instead of invisible a better option would have been to make semi transparent.\r\n     *   Unfortunately, unlike mesh, mesh instances do not \"visibility\" setting)\r\n     *   Every alternate frame make mesh visible and invisible to give the impression of semi-transparent.\r\n     * b) move the camera in front of the obstructing mesh\r\n     */\r\n    private _handleObstruction() {\r\n\r\n        //get vector from av (camera.target) to camera\r\n        this._camera.position.subtractToRef(this._camera.target, this._rayDir);\r\n        //start ray from av to camera\r\n        this._ray.origin = this._camera.target;\r\n        this._ray.length = this._rayDir.length();\r\n        this._ray.direction = this._rayDir.normalize();\r\n\r\n\r\n        //do not pick a mesh if it is the avatar or any of its children (like attachments etc)\r\n        const pis: PickingInfo[] = this._scene.multiPickWithRay(this._ray, (mesh) => {\r\n            if (this._avChildren.includes(mesh)) return false;\r\n            if (mesh.isPickable) {\r\n                return true;\r\n            }else{ \r\n                return false;\r\n            }\r\n        });\r\n\r\n\r\n        if (this._makeInvisible) {\r\n            this._prevPickedMeshes = this._pickedMeshes;\r\n            if (pis.length > 0) {\r\n                this._pickedMeshes = new Array();\r\n                for (let pi of pis) {\r\n                    if (pi.pickedMesh.isVisible || this._prevPickedMeshes.includes(pi.pickedMesh)) {\r\n                        pi.pickedMesh.isVisible = false;\r\n                        this._pickedMeshes.push(pi.pickedMesh);\r\n                    }\r\n                }\r\n                for (let pm of this._prevPickedMeshes) {\r\n                    if (!this._pickedMeshes.includes(pm)) {\r\n                        pm.isVisible = true;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let pm of this._prevPickedMeshes) {\r\n                    pm.isVisible = true;\r\n                }\r\n                this._prevPickedMeshes.length = 0;\r\n            }\r\n        }\r\n\r\n        if (this._cameraElastic) {\r\n            if (pis.length > 0) {\r\n                // postion the camera in front of the mesh that is obstructing camera\r\n\r\n                //if only one obstruction and it is invisible then if it is not collidable or our camera is not collidable then do nothing\r\n                if ((pis.length == 1 && !this._isSeeAble(pis[0].pickedMesh)) && (!pis[0].pickedMesh.checkCollisions || !this._camera.checkCollisions)) return;\r\n\r\n                //if our camera is collidable then we donot want it to get stuck behind another collidable obsrtucting mesh\r\n                let pp: Vector3 = null;\r\n\r\n                //we will asume the order of picked meshes is from closest to avatar to furthest\r\n                //we should get the first one which is visible or invisible and collidable\r\n                for (let i = 0; i < pis.length; i++) {\r\n                    let pm = pis[i].pickedMesh;\r\n                    if (this._isSeeAble(pm)) {\r\n                        pp = pis[i].pickedPoint;\r\n                        break;\r\n                    } else if (pm.checkCollisions) {\r\n                        pp = pis[i].pickedPoint;\r\n                        break;\r\n                    }\r\n                }\r\n                if (pp == null) return;\r\n\r\n                const c2p: Vector3 = this._camera.position.subtract(pp);\r\n                //note that when camera is collidable, changing the orbital camera radius may not work.\r\n                //changing the radius moves the camera forward (with collision?) and collision can interfere with movement\r\n                //\r\n                //in every cylce we are dividing the distance to tarvel by same number of steps.\r\n                //as we get closer to destination the speed will thus slow down.\r\n                //when just 1 unit distance left, lets snap to the final position.\r\n                //when calculating final position make sure the camera does not get stuck at the pickposition especially\r\n                //if collision is on\r\n\r\n                const l: number = c2p.length();\r\n                if (this._camera.checkCollisions) {\r\n                    let step: Vector3;\r\n                    if (l <= 1) {\r\n                        step = c2p.addInPlace(c2p.normalizeToNew().scaleInPlace(this._cameraSkin));\r\n                    } else {\r\n                        step = c2p.normalize().scaleInPlace(l / this._elasticSteps);\r\n                    }\r\n                    this._camera.position = this._camera.position.subtract(step);\r\n                } else {\r\n                    let step: number;\r\n                    if (l <= 1) step = l + this._cameraSkin; else step = l / this._elasticSteps;\r\n                    this._camera.radius = this._camera.radius - (step);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //how many ways can a mesh be invisible?\r\n    private _isSeeAble(mesh: AbstractMesh): boolean {\r\n        if (!mesh.isVisible) return false;\r\n        if (mesh.visibility == 0) return false;\r\n        if (mesh.material != null && mesh.material.alphaMode != 0 && mesh.material.alpha == 0) return false;\r\n        return true;\r\n        //what about vertex color? groan!\r\n    }\r\n\r\n\r\n    private _move: boolean = false;\r\n    public anyMovement(): boolean {\r\n        return (this._act._walk || this._act._walkback || this._act._turnLeft || this._act._turnRight || this._act._stepLeft || this._act._stepRight);\r\n    }\r\n\r\n    private _onKeyDown(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        if (e.repeat) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case this._actionMap.idleJump.key:\r\n                this._act._jump = true;\r\n                break;\r\n            case \"capslock\":\r\n                this._act._speedMod = !this._act._speedMod;\r\n                break;\r\n            case \"shift\":\r\n                this._act._speedMod = true;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk.key:\r\n                // console.log(\"walk\");\r\n                this._act._walk = true;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft.key:\r\n                // console.log(\"turn left\");\r\n                this._act._turnLeft = true;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight.key:\r\n                // console.log(\"turn right\");\r\n                this._act._turnRight = true;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack.key:\r\n                // console.log(\"walk back\");\r\n                this._act._walkback = true;\r\n                break;\r\n            case this._actionMap.strafeLeft.key:\r\n                // console.log(\"strafe left\");\r\n                this._act._stepLeft = true;\r\n                break;\r\n            case this._actionMap.strafeRight.key:\r\n                // console.log(\"strafe right\");\r\n                this._act._stepRight = true;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _onKeyUp(e: KeyboardEvent) {\r\n        if (!e.key) return;\r\n        switch (e.key.toLowerCase()) {\r\n            case \"shift\":\r\n                this._act._speedMod = false;\r\n                break;\r\n            case \"up\":\r\n            case \"arrowup\":\r\n            case this._actionMap.walk.key:\r\n                this._act._walk = false;\r\n                break;\r\n            case \"left\":\r\n            case \"arrowleft\":\r\n            case this._actionMap.turnLeft.key:\r\n                this._act._turnLeft = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"right\":\r\n            case \"arrowright\":\r\n            case this._actionMap.turnRight.key:\r\n                this._act._turnRight = false;\r\n                this._isTurning = false;\r\n                break;\r\n            case \"down\":\r\n            case \"arrowdown\":\r\n            case this._actionMap.walkBack.key:\r\n                this._act._walkback = false;\r\n                break;\r\n            case this._actionMap.strafeLeft.key:\r\n                this._act._stepLeft = false;\r\n                break;\r\n            case this._actionMap.strafeRight.key:\r\n                this._act._stepRight = false;\r\n                break;\r\n        }\r\n        this._move = this.anyMovement();\r\n    }\r\n\r\n    private _ekb: boolean = true;\r\n    public isKeyBoardEnabled(): boolean {\r\n        return this._ekb;\r\n    }\r\n    public enableKeyBoard(b: boolean) {\r\n        this._ekb = b;\r\n        if (b) {\r\n            this._addkeylistener();\r\n        } else {\r\n            this._removekeylistener();\r\n        }\r\n    }\r\n\r\n    private _addkeylistener() {\r\n        let canvas: HTMLCanvasElement = this._scene.getEngine().getRenderingCanvas();\r\n        canvas.addEventListener(\"keyup\", this._handleKeyUp, false);\r\n        canvas.addEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    private _removekeylistener() {\r\n        let canvas: HTMLCanvasElement = this._scene.getEngine().getRenderingCanvas();\r\n        canvas.removeEventListener(\"keyup\", this._handleKeyUp, false);\r\n        canvas.removeEventListener(\"keydown\", this._handleKeyDown, false);\r\n    }\r\n\r\n    // control movement by commands rather than keyboard.\r\n    public walk(b: boolean) {\r\n        this._act._walk = b;\r\n    }\r\n    public walkBack(b: boolean) {\r\n        this._act._walkback = b;\r\n    }\r\n    public walkBackFast(b: boolean) {\r\n        this._act._walkback = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public run(b: boolean) {\r\n        this._act._walk = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnLeft(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnLeftFast(b: boolean) {\r\n        this._act._turnLeft = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public turnRight(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n    }\r\n    public turnRightFast(b: boolean) {\r\n        this._act._turnRight = b;\r\n        if (!b) this._isTurning = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeLeft(b: boolean) {\r\n        this._act._stepLeft = b;\r\n    }\r\n    public strafeLeftFast(b: boolean) {\r\n        this._act._stepLeft = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public strafeRight(b: boolean) {\r\n        this._act._stepRight = b;\r\n    }\r\n    public strafeRightFast(b: boolean) {\r\n        this._act._stepRight = b;\r\n        this._act._speedMod = b;\r\n    }\r\n    public jump() {\r\n        this._act._jump = true;\r\n    }\r\n\r\n    public fall() {\r\n        this._grounded = false;\r\n    }\r\n\r\n    public idle() {\r\n        this._act.reset();\r\n    }\r\n\r\n    private _act: _Action;\r\n    private _renderer: () => void;\r\n    private _handleKeyUp: (e) => void;\r\n    private _handleKeyDown: (e) => void;\r\n    private _isAG: boolean = false;\r\n    public isAg() {\r\n        return this._isAG;\r\n    }\r\n\r\n\r\n\r\n\r\n    private _findSkel(n: Node): Skeleton {\r\n        let root = this._root(n);\r\n\r\n        if (root instanceof Mesh && root.skeleton) return root.skeleton;\r\n\r\n        //find all child meshes which have skeletons\r\n        let ms = root.getChildMeshes(\r\n            false,\r\n            (cm) => {\r\n                if (cm instanceof Mesh) {\r\n                    if (cm.skeleton) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            });\r\n\r\n        //return the skeleton of the first child mesh\r\n        if (ms.length > 0) return ms[0].skeleton; else return null;\r\n\r\n    }\r\n\r\n    private _root(tn: Node): Node {\r\n        if (tn.parent == null) return tn;\r\n        return this._root(tn.parent);\r\n    }\r\n\r\n    private _getAbstractMeshChildren(tn: Node): AbstractMesh[] {\r\n        let ms: AbstractMesh[] = new Array();\r\n        if (tn instanceof AbstractMesh) ms.push(tn);\r\n        tn.getChildren((cm) => {\r\n            if (cm instanceof AbstractMesh) ms.push(cm);\r\n            return false;\r\n        },\r\n        false)\r\n        return ms;  \r\n    }\r\n\r\n    public setAvatar(avatar: Mesh, faceForward: boolean = false): boolean {\r\n\r\n        let rootNode = this._root(avatar);\r\n        if (rootNode instanceof Mesh) {\r\n            this._avatar = rootNode;\r\n        } else {\r\n            console.error(\"Cannot move this mesh. The root node of the mesh provided is not a mesh\");\r\n            return false;\r\n        }\r\n        this._avChildren = this._getAbstractMeshChildren(rootNode);\r\n        this._skeleton = this._findSkel(avatar);\r\n        this._isAG = this._containsAG(avatar, this._scene.animationGroups, true);\r\n\r\n        this._actionMap.reset();\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n\r\n        this._setRHS(avatar);\r\n        this.setFaceForward(faceForward);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    private _ellipsoid:TransformNode = null;\r\n    public showEllipsoid(show:boolean) {\r\n        if (!show){\r\n            if (this._ellipsoid != null) this._ellipsoid.dispose();\r\n            this._ellipsoid = null;\r\n            if (this._rayLine != null) { this._rayLine.dispose(); this._rayLine = null; }\r\n            return;\r\n        }\r\n        let ellipsoid:TransformNode = new TransformNode(\"ellipsoid\", this._scene);\r\n        \r\n        let a = this._avatar.ellipsoid.x;\r\n        let b = this._avatar.ellipsoid.y;\r\n\r\n        const points = [];\r\n        for(let theta = -Math.PI/2; theta < Math.PI/2; theta += Math.PI/36) {\r\n            points.push(new BABYLON.Vector3(0, b * Math.sin(theta), a * Math.cos(theta)));\r\n        }\r\n    \r\n        const ellipse : LinesMesh[] = [];\r\n        ellipse[0] = MeshBuilder.CreateLines(\"e\", {points:points}, this._scene);\r\n        ellipse[0].color = Color3.Red();\r\n        ellipse[0].parent = ellipsoid;\r\n        ellipse[0].isPickable = false;\r\n        const steps = 12;\r\n        const dTheta = 2 * Math.PI / steps; \r\n        for(let i = 1; i < steps; i++) {\r\n                ellipse[i] = ellipse[0].clone(\"el\" + i);\r\n                ellipse[i].parent = ellipsoid;\r\n                ellipse[i].rotation.y = i * dTheta;\r\n                ellipse[i].isPickable = false;\r\n        }\r\n        ellipsoid.parent = this._avatar;\r\n        ellipsoid.position = this._avatar.ellipsoidOffset;\r\n        this._ellipsoid= ellipsoid;\r\n    }\r\n\r\n    public getAvatar() {\r\n        return this._avatar;\r\n    }\r\n\r\n    // force a skeleton to be the avatar skeleton\r\n    // should not be calling this normally\r\n    public setAvatarSkeleton(skeleton: Skeleton) {\r\n        this._skeleton = skeleton;\r\n\r\n\r\n        if (this._skeleton != null && this._skelDrivenByAG(skeleton)) this._isAG = true; else this._isAG = false;\r\n\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n    }\r\n\r\n\r\n    // this check if any of this skeleton animations is referenced by any targetedAnimation in any of the animationgroup in the scene.\r\n    private _skelDrivenByAG(skeleton: Skeleton) {\r\n        return skeleton.animations.some(sa => this._scene.animationGroups.some(ag => ag.children.some(ta => ta.animation == sa)));\r\n    }\r\n\r\n    public getSkeleton() {\r\n        return this._skeleton;\r\n    }\r\n\r\n    // does this character have any animations ?\r\n    // remember we can use meshes without anims as characters too\r\n    private _hasAnims: boolean = false;\r\n    private _hasCam: boolean = true;\r\n    //av children will be used if elastic camera is set to true\r\n    //pick collision with children will ignored then\r\n    private _avChildren:AbstractMesh[];\r\n\r\n    /**\r\n     * The avatar/character can be made up of multiple meshes arranged in a hierarchy.\r\n     * As such we will pick the root of the hierarchy as the avatar.\r\n     * The root should be a mesh as otherwise we cannot move it with moveWithCollision() method.\r\n     * \r\n     * Mutiple meshes in the hierarchy may have skeletons (if two or more meshes have skeleton then\r\n     * the skeleton will mostly likely be the same). \r\n     * So we will pick as avatar skeleton, the  skeleton of the first mesh in the hierachy which has\r\n     * a skeleton \r\n     * \r\n     * @param avatar \r\n     * @param camera \r\n     * @param scene \r\n     * @param actionMap/animationGroupMap \r\n     *        maps actions to animations and other data like speed,sound etc \r\n     *        or \r\n     *        for backward compatibility could be AnimationGroup Map\r\n     * @param faceForward \r\n     */\r\n    constructor(avatar: Mesh, camera: ArcRotateCamera, scene: Scene, actionMap?: {}, faceForward = false) {\r\n\r\n        this._camera = camera;\r\n\r\n        //if camera is null assume this would be used to control an NPC\r\n        //we cannot use mode 0 as that is dependent on camera being present. so force mode 1\r\n        if (this._camera == null) {\r\n            this._hasCam = false;\r\n            this.setMode(1);\r\n        }\r\n        this._scene = scene;\r\n\r\n        let success = this.setAvatar(avatar, faceForward);\r\n        if (!success) {\r\n            console.error(\"unable to set avatar\");\r\n        }\r\n\r\n        let dataType: string = null;\r\n        if (actionMap != null) {\r\n            dataType = this.setActionMap(<ActionMap>actionMap);\r\n        }\r\n\r\n        //try to use the existing avatar animations\r\n\r\n        //animation ranges\r\n        if (!this._isAG && this._skeleton != null) this._checkAnimRanges(this._skeleton);\r\n        //animation groups\r\n        if (this._isAG) {\r\n            //TODO\r\n        }\r\n\r\n        if (this._hasCam) this._savedCameraCollision = this._camera.checkCollisions;\r\n\r\n        // this._avatar.onCollideObservable.add(\r\n        //     function(m,evt){\r\n        //         let msg = \"Collision with: \"+m.name;\r\n        //         console.log(m);\r\n        //         console.log(evt);\r\n        //     }\r\n        // );    \r\n\r\n\r\n        this._act = new _Action();\r\n\r\n        this._renderer = () => { this._moveAVandCamera() };\r\n        this._handleKeyUp = (e) => { this._onKeyUp(e) };\r\n        this._handleKeyDown = (e) => { this._onKeyDown(e) };\r\n    }\r\n}\r\n\r\n\r\n\r\nclass _Action {\r\n\r\n    public _walk: boolean = false;\r\n    public _walkback: boolean = false;\r\n    public _turnRight: boolean = false;\r\n    public _turnLeft: boolean = false;\r\n    public _stepRight: boolean = false;\r\n    public _stepLeft: boolean = false;\r\n    public _jump: boolean = false;\r\n\r\n    // speed modifier - changes speed of movement\r\n    public _speedMod: boolean = false;\r\n\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this._walk = false;\r\n        this._walkback = false;\r\n        this._turnRight = false;\r\n        this._turnLeft = false;\r\n        this._stepRight = false;\r\n        this._stepLeft = false;\r\n        this._jump = false;\r\n        this._speedMod = false;\r\n    }\r\n}\r\n\r\nexport class ActionData {\r\n    public id: string;\r\n    public speed: number;\r\n    //_ds default speed.  speed is set to this on reset\r\n    public ds: number;\r\n    public sound: Sound;\r\n    public key: string;\r\n    //_dk defailt key\r\n    public dk: string;\r\n\r\n    //animation data\r\n    //if _ag is null then assuming animation range and use _name to play animationrange\r\n    //instead of name maybe call it arName?\r\n    public name: string = \"\";\r\n    public ag: AnimationGroup;\r\n    public loop: boolean = true;\r\n    public rate: number = 1;\r\n\r\n    public exist: boolean = false;\r\n\r\n    public constructor(id?: string, speed = 1, key?: string) {\r\n        this.id = id;\r\n        this.speed = speed;\r\n        this.ds = speed;\r\n        this.key = key;\r\n        this.dk = key;\r\n    }\r\n\r\n    public reset() {\r\n        this.name = \"\";\r\n        this.speed = this.ds;\r\n        this.key = this.dk;\r\n        this.loop = true;\r\n        this.rate = 1;\r\n        this.sound = null;\r\n        this.exist = false;\r\n    }\r\n\r\n}\r\n\r\n//not really a \"Map\"\r\nexport class ActionMap {\r\n    public walk = new ActionData(\"walk\", 3, \"w\");\r\n    public walkBack = new ActionData(\"walkBack\", 1.5, \"s\");\r\n    public walkBackFast = new ActionData(\"walkBackFast\", 3, \"na\");\r\n    public idle = new ActionData(\"idle\", 0, \"na\");\r\n    public idleJump = new ActionData(\"idleJump\", 6, \" \");\r\n    public run = new ActionData(\"run\", 6, \"na\");\r\n    public runJump = new ActionData(\"runJump\", 6, \"na\");\r\n    public fall = new ActionData(\"fall\", 0, \"na\");\r\n    public turnLeft = new ActionData(\"turnLeft\", Math.PI / 8, \"a\");\r\n    public turnLeftFast = new ActionData(\"turnLeftFast\", Math.PI / 4, \"na\");\r\n    public turnRight = new ActionData(\"turnRight\", Math.PI / 8, \"d\");\r\n    public turnRightFast = new ActionData(\"turnRightFast\", Math.PI / 4, \"na\");\r\n    public strafeLeft = new ActionData(\"strafeLeft\", 1.5, \"q\");\r\n    public strafeLeftFast = new ActionData(\"strafeLeftFast\", 3, \"na\");\r\n    public strafeRight = new ActionData(\"strafeRight\", 1.5, \"e\");\r\n    public strafeRightFast = new ActionData(\"strafeRightFast\", 3, \"na\");\r\n    public slideBack = new ActionData(\"slideBack\", 0, \"na\");\r\n\r\n    public reset() {\r\n        let keys: string[] = Object.keys(this);\r\n        for (let key of keys) {\r\n            let act = this[key];\r\n            if (!(act instanceof ActionData)) continue;\r\n            act.reset()\r\n        }\r\n    }\r\n};\r\n\r\nexport class CCSettings {\r\n    public faceForward: boolean;\r\n    public gravity: number;\r\n    public minSlopeLimit: number;\r\n    public maxSlopeLimit: number;\r\n    public stepOffset: number;\r\n    public cameraElastic: boolean = true;\r\n    public elasticSteps: number;\r\n    public makeInvisble: boolean = true;\r\n    public cameraTarget: Vector3 = Vector3.Zero();\r\n    public noFirstPerson: boolean = false;\r\n    public topDown: boolean = true;\r\n    //turningOff takes effect only when topDown is false\r\n    public turningOff: boolean = true;\r\n    public keyboard: boolean = true;\r\n    public sound: Sound;\r\n}\r\n"],"names":[],"sourceRoot":""}